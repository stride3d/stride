using CommunityToolkit.HighPerformance;
using CommunityToolkit.HighPerformance.Buffers;
using Stride.Shaders.Core;
using Stride.Shaders.Parsing;
using Stride.Shaders.Parsing.Analysis;
using Stride.Shaders.Parsing.SDSL;
using Stride.Shaders.Parsing.SDSL.AST;
using Stride.Shaders.Spirv.Core;
using Stride.Shaders.Spirv.Core.Buffers;
using Stride.Shaders.Spirv.Processing;
using Stride.Shaders.Spirv.Tools;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using Stride.Core.Storage;
using static Stride.Shaders.Spirv.Specification;

namespace Stride.Shaders.Spirv.Building;

public record class ShaderMixinInstantiation(List<ShaderClassInstantiation> Mixins, Dictionary<string, ShaderMixinInstantiation[]> Compositions);

public record struct ShaderBuffers(SpirvContext Context, NewSpirvBuffer Buffer);

public enum ResolveStep
{
    Compile,
    Mix,
}

public record class ShaderClassInstantiation(string ClassName, int[] GenericArguments, bool ImportStageOnly = false) : IEquatable<ShaderClassInstantiation>
{
    public ShaderBuffers? Buffer { get; set; }

    public string ClassName { get; set; } = ClassName;

    public int[] GenericArguments { get; set; } = GenericArguments;

    public LoadedShaderSymbol Symbol { get; set; }

    public string ToClassNameWithGenerics()
    {
        if ((GenericArguments == null || GenericArguments.Length == 0) && !ImportStageOnly)
            return ClassName;

        var result = new StringBuilder();
        result.Append(ClassName);
        if (GenericArguments != null && GenericArguments.Length > 0)
        {
            result.Append('<');
            result.Append(string.Join(",", GenericArguments.Select(x => $"%{x}")));
            result.Append('>');
        }

        return result.ToString();
    }

    public override string ToString() => $"{(ImportStageOnly ? "stage " : string.Empty)}{ToClassNameWithGenerics()} Symbol: {Symbol} Buffer: {(Buffer != null ? "set" : "empty")}";

    public virtual bool Equals(ShaderClassInstantiation? shaderClassSource)
    {
        if (shaderClassSource is null) return false;
        if (ReferenceEquals(this, shaderClassSource)) return true;
        return
            string.Equals(ClassName, shaderClassSource.ClassName) &&
            GenericArguments.SequenceEqual(shaderClassSource.GenericArguments);
    }

    public override int GetHashCode()
    {
        unchecked
        {
            int hashCode = ClassName?.GetHashCode() ?? 0;
            if (GenericArguments != null)
            {
                foreach (var current in GenericArguments)
                    hashCode = (hashCode * 397) ^ (current.GetHashCode());
            }

            return hashCode;
        }
    }
}

// Constant vector (generated by TryGetConstantValue)
public class ConstantVector
{
    public object[] Values;

    public override string ToString()
    {
        var type = Values[0] switch
        {
            float => "float",
        };

        return $"{type}{Values.Length}({string.Join(",", Values)})";
    }
}


public partial class SpirvBuilder
{
    public static void BuildInheritanceListWithoutSelf(IExternalShaderLoader shaderLoader, SpirvContext topLevelContext, ShaderClassInstantiation classSource, ReadOnlySpan<ShaderMacro> macros, SpirvContext declaringContext, List<ShaderClassInstantiation> inheritanceList, ResolveStep resolveStep)
    {
        // Build shader name mapping
        var shaderMapping = new Dictionary<int, ShaderClassInstantiation>();
        var genericParameterRemapping = new Dictionary<int, int>();
        foreach (var i in declaringContext)
        {
            if (i.Op == Op.OpSDSLGenericParameter && (OpSDSLGenericParameter)i is { } genericParameter)
            {
                if (genericParameter.Index >= classSource.GenericArguments.Length)
                    throw new NotImplementedException($"Not enough generic parameters specified when instantiating {classSource.ToClassNameWithGenerics()}");
                genericParameterRemapping.Add(genericParameter.ResultId, classSource.GenericArguments[genericParameter.Index]);
            }
            if (i.Op == Op.OpSDSLImportShader && (OpSDSLImportShader)i is { } importShader)
            {
                var shaderClassSource = ConvertToShaderClassSource(declaringContext, importShader);

                shaderMapping[importShader.ResultId] = shaderClassSource;
            }
        }

        int RemapGenericParameter(int localGeneric)
        {
            if (genericParameterRemapping.TryGetValue(localGeneric, out var generic))
                return generic;

            // Otherwise, assume it's a constsant we need to import
            var constantBuffer = declaringContext.ExtractConstantAsSpirvBuffer(localGeneric);
            var resultId = topLevelContext.InsertWithoutDuplicates(null, constantBuffer);

            return resultId;
        }

        // Check inheritance
        foreach (var i in declaringContext)
        {
            if (i.Op == Op.OpSDSLMixinInherit && (OpSDSLMixinInherit)i is { } inherit)
            {
                var shaderName = shaderMapping[inherit.Shader];

                // Remap/import generics
                var remappedGenericArguments = shaderName.GenericArguments.ToArray();
                for (int index = 0; index < remappedGenericArguments.Length; index++)
                    remappedGenericArguments[index] = RemapGenericParameter(remappedGenericArguments[index]);

                var remappedShaderName = shaderName with { GenericArguments = remappedGenericArguments };
                BuildInheritanceListIncludingSelf(shaderLoader, topLevelContext, remappedShaderName, macros, inheritanceList, resolveStep);
            }
        }
    }

    public static ShaderClassInstantiation ConvertToShaderClassSource(SpirvContext declaringContext, OpSDSLImportShader importShader)
    {
        return new ShaderClassInstantiation(importShader.ShaderName, importShader.Values.Elements.Memory.ToArray());
    }

    public static ShaderClassInstantiation BuildInheritanceListIncludingSelf(IExternalShaderLoader shaderLoader, SpirvContext context, ShaderClassInstantiation classSource, ReadOnlySpan<ShaderMacro> macros, List<ShaderClassInstantiation> inheritanceList, ResolveStep resolveStep)
    {
        // TODO: cache same instantiations within context?
        var index = inheritanceList.IndexOf(classSource);
        if (index == -1)
        {
            if (classSource.Buffer == null)
            {
                var shader = GetOrLoadShader(shaderLoader, classSource, macros, resolveStep, context);
                classSource.Buffer = shader;
            }

            // Note: since shader instantiation might mutate classSource, perform a search again
            index = inheritanceList.IndexOf(classSource);
            if (index == -1)
            {
                BuildInheritanceListWithoutSelf(shaderLoader, context, classSource, macros, classSource.Buffer.Value.Context, inheritanceList, resolveStep);
                index = inheritanceList.Count;
                inheritanceList.Add(classSource);
            }
        }

        return inheritanceList[index];
    }

    record struct GenericParameter(SymbolType Type, int ResultId, int ResultType, int Index, string Name, bool Resolved, string Value);

    abstract class GenericResolver
    {
        public abstract int GenericArgumentCount { get; }
        public virtual IShaderCache? Cache => null;

        public abstract string ResolveGenericAsString(int genericIndex);

        public abstract bool TryResolveGenericValue(SymbolType genericParameterType, string genericParameterName, int index, out object value);
        public abstract bool ResolveGenericValueInBuffer(SymbolType genericParameterType, string genericParameterName, int genericIndex, SpirvContext context, ref int instructionIndex, out string textValue);

        public virtual void ValidateGenericParameters(string classNameWithGenerics, List<GenericParameter> genericParameters)
        {
        }

        /// <summary>
        /// This will be executed in all cases for generic classes (even if generic instantiation was in the cache). 
        /// </summary>
        /// <param name="classNameWithGenerics"></param>
        public virtual void PostProcess(string classNameWithGenerics)
        {
        }
    }

    /// <summary>
    /// Instantiate generics using string values (they will be imported in the generic shader being specialized).
    /// </summary>
    class GenericResolverFromValues(string[]? genericValues) : GenericResolver
    {
        public override int GenericArgumentCount => genericValues?.Length ?? 0;
        public override string ResolveGenericAsString(int genericIndex) => genericValues[genericIndex];

        public override bool TryResolveGenericValue(SymbolType genericParameterType, string genericParameterName, int index, out object value)
        {
            var genericValue = genericValues![index];
            switch (genericParameterType)
            {
                case ScalarType { Type: Scalar.Int }:
                    value = int.Parse(genericValue);
                    return true;
                case ScalarType { Type: Scalar.Float }:
                    value = float.Parse(genericValue);
                    return true;
                case ScalarType { Type: Scalar.Boolean }:
                    value = bool.Parse(genericValue);
                    return true;
                case GenericParameterType g:
                    value = genericValue;
                    return true;
                default:
                    throw new NotImplementedException();
            }
        }

        public override bool ResolveGenericValueInBuffer(SymbolType genericParameterType, string genericParameterName, int genericIndex, SpirvContext context, ref int instructionIndex, out string textValue)
        {
            var genericParameter = (OpSDSLGenericParameter)context[instructionIndex];
            var genericValue = genericValues![genericIndex];
            textValue = genericValue;
            switch (genericParameterType)
            {
                case ScalarType or VectorType:
                    var scanner = new Scanner(textValue);
                    ParseResult pr = new ParseResult();
                    if (!ExpressionParser.Expression(ref scanner, pr, out var expression))
                        throw new InvalidOperationException("Can't parse generic value");
                    var localContext = new SpirvContext();
                    var result = expression.CompileConstantValue(new SymbolTable(localContext), localContext, genericParameterType);
                    context.RemoveAt(instructionIndex);
                    context.InsertWithoutDuplicates(ref instructionIndex, genericParameter.ResultId, localContext.GetBuffer());
                    return true;
                case GenericParameterType g:
                    context.Replace(instructionIndex++, new OpConstantStringSDSL(genericParameter.ResultId, genericValue));
                    return true;
                default:
                    throw new NotImplementedException();
            }
        }
    }

    /// <summary>
    /// Instantiate generics using another buffer for the shader constants. If a context is specified, constants will be imported there, otherwise inside the generic shader being instantiated.
    /// </summary>
    class GenericResolverFromInstantiatingBuffer(ShaderClassInstantiation classSource, ResolveStep resolveStep, SpirvContext declaringContext) : GenericResolver
    {
        public override int GenericArgumentCount => classSource.GenericArguments.Length;

        public override IShaderCache? Cache => declaringContext.GenericCache;

        public override string ResolveGenericAsString(int genericIndex)
        {
            var constantId = classSource.GenericArguments[genericIndex];
            if (!declaringContext.GenericValueCache.TryGetValue(constantId, out var textValue))
            {
                textValue = declaringContext.TryGetConstantValue(constantId, out var constantValue, out _, false)
                    ? constantValue.ToString()
                    : GetIdRefAsString(genericIndex);
                
                declaringContext.GenericValueCache.Add(constantId, textValue);
            }

            return textValue;
        }

        private string GetIdRefAsString(int index)
        {
            return declaringContext.Names.TryGetValue(classSource.GenericArguments[index], out var genericArgumentName)
                ? $"%{genericArgumentName}[{classSource.GenericArguments[index]}]"
                : $"%{classSource.GenericArguments[index]}";
        }

        public override bool TryResolveGenericValue(SymbolType genericParameterType, string genericParameterName, int index, out object value)
        {
            if (!declaringContext.TryGetConstantValue(classSource.GenericArguments[index], out value, out _, false))
            {
                value = GetIdRefAsString(index);
                return false;
            }

            return true;
        }

        public override bool ResolveGenericValueInBuffer(SymbolType genericParameterType, string genericParameterName, int genericIndex, SpirvContext context, ref int instructionIndex, out string textValue)
        {
            // TODO: optimization: if it can be resolved fully (declaringContext.TryGetConstantValue succeeds), we could simply use/inject the value as is
            textValue = ResolveGenericAsString(genericIndex);

            var genericParameter = (OpSDSLGenericParameter)context[instructionIndex];
            var bufferWithConstant = declaringContext.ExtractConstantAsSpirvBuffer(classSource.GenericArguments[genericIndex]);

            bool resolved = true;

            // Remap OpSDSLGenericParameter to OpSDSLGenericReference
            for (int index = 0; index < bufferWithConstant.Count; ++index)
            {
                var i = bufferWithConstant[index];

                if (i.Op == Op.OpSDSLGenericParameter && (OpSDSLGenericParameter)i is { } genericParameter2)
                {
                    bufferWithConstant.Replace(index, new OpSDSLGenericReference(genericParameter2.ResultType, genericParameter2.ResultId, genericParameter2.Index, genericParameter2.DeclaringClass));
                    resolved = false;
                }
            }

            context.RemoveAt(instructionIndex);

            // TODO: Try to simplify constant
            var bound = context.Bound;
            int resultId = context.InsertWithoutDuplicates(ref instructionIndex, genericParameter.ResultId, bufferWithConstant);
            context.Bound = bound;

            return true;
        }

        public override void ValidateGenericParameters(string classNameWithGenerics, List<GenericParameter> genericParameters)
        {
            // Fully resolved?
            if (resolveStep == ResolveStep.Mix)
            {
                if (!genericParameters.All(x => x.Resolved))
                {
                    throw new InvalidOperationException("During mix phase, shaders generics are expected to be fully resolved");
                }
            }
        }

        public override void PostProcess(string classNameWithGenerics)
        {
            if (resolveStep == ResolveStep.Mix)
            {
                classSource.ClassName = classNameWithGenerics;
                classSource.GenericArguments = [];
            }
        }
    }

    private static void InstantiateGenericShader(ref ShaderBuffers shaderBuffers, string classNameWithGenerics, GenericResolver genericResolver, IExternalShaderLoader shaderLoader, ReadOnlySpan<ShaderMacro> macros)
    {
        var resolvedLinks = new Dictionary<int, string>();
        var semantics = new Dictionary<string, string>();
        
        var genericParameters = new List<GenericParameter>();
        for (int index = 0; index < shaderBuffers.Context.Count; ++index)
        {
            var i = shaderBuffers.Context[index];
            if (i.Op == Op.OpSDSLGenericParameter && (OpSDSLGenericParameter)i is { } genericParameter)
            {
                var genericParameterType = shaderBuffers.Context.ReverseTypes[genericParameter.ResultType];
                var genericParameterName = shaderBuffers.Context.Names[genericParameter.ResultId];
                var instructionStart = index;
                var resolved = genericResolver.ResolveGenericValueInBuffer(genericParameterType, genericParameterName, genericParameters.Count, shaderBuffers.Context, ref index, out var textValue);
                genericParameters.Add(new(genericParameterType, genericParameter.ResultId, genericParameter.ResultType, i.Index, genericParameterName, resolved, textValue));

                // Process new types (if any)
                // Note: this might fail in case of types being reordered? (review that if it happens in more advanced cases)
                ShaderClass.ProcessNameAndTypes(shaderBuffers.Context, instructionStart, index);

                // Since we are positioned after the newly added instruction, adjust for it to consider next loop ++index
                index--;

                switch (genericParameterType)
                {
                    case GenericParameterType g when g.Kind is GenericParameterKindSDSL.LinkType:
                        resolvedLinks.Add(genericParameter.ResultId, textValue);
                        break;
                    case GenericParameterType g when g.Kind is GenericParameterKindSDSL.Semantic:
                        semantics.Add(shaderBuffers.Context.Names[genericParameter.ResultId], textValue);
                        break;
                }
            }

            if (i.Op == Op.OpTypeArray && (OpTypeArray)i is { } typeArray)
            {
                // Make sure constant is a proper OpConstant (i.e. not an OpSpecConstant)
                if (!shaderBuffers.Context.GetBuffer().TryGetInstructionById(typeArray.Length, out var lengthInstruction))
                    throw new InvalidOperationException();
                if (lengthInstruction.Op != Op.OpConstant && shaderBuffers.Context.TryGetConstantValue(typeArray.Length, out var value, out _, true))
                {
                }
            }
        }

        //Console.WriteLine($"[Shader] Instantiating {classNameWithGenerics}");

        foreach (var i in shaderBuffers.Buffer)
        {
            if (i.Op == Op.OpSDSLShader && (OpSDSLShader)i is { } shaderDeclaration)
                shaderDeclaration.ShaderName = classNameWithGenerics;
        }

        TransformResolvedSemantics(shaderBuffers.Context, semantics);
        TransformResolvedLinkIdIntoLinkString(shaderBuffers.Context, resolvedLinks);

        genericResolver.ValidateGenericParameters(classNameWithGenerics, genericParameters);
    }

    private static string BuildGenericClassName(string className, GenericResolver resolver)
    {
        StringBuilder sb = new();
        sb.Append(className).Append("<");

        for (int i = 0; i < resolver.GenericArgumentCount; i++)
        {
            if (i > 0)
                sb.Append(",");
            sb.Append(resolver.ResolveGenericAsString(i));
        }
        sb.Append(">");
        return sb.ToString();
    }

    private static void TransformResolvedSemantics(SpirvContext context, Dictionary<string, string> semantics)
    {
        foreach (var i in context)
        {
            if (i.Op == Op.OpDecorateString && (OpDecorateString)i is { Decoration: Decoration.UserSemantic, Value: string m } decorate)
            {
                if (semantics.TryGetValue(m, out var newSemantic))
                    decorate.Value = newSemantic;
            }
            else if (i.Op == Op.OpMemberDecorateString && (OpMemberDecorateString)i is { Decoration: Decoration.UserSemantic, Value : string m2 } decorate2)
            {
                if (semantics.TryGetValue(m2, out var newSemantic))
                    decorate2.Value = newSemantic;
            }
        }
    }

    private static void InstantiateMemberNames(ref ShaderBuffers shaderBuffers, string shaderName, GenericResolver genericResolver, IExternalShaderLoader shaderLoader, ReadOnlySpan<ShaderMacro> macros)
    {
        bool hasUnresolvableShader = false;
        for (var index = 0; index < shaderBuffers.Buffer.Count; index++)
        {
            var i = shaderBuffers.Buffer[index];
            if (i.Op == Op.OpUnresolvableShaderSDSL && (OpUnresolvableShaderSDSL)i is { } unresolvableShader)
            {
                hasUnresolvableShader = true;
            }
        }

        if (!hasUnresolvableShader)
            return;

        var instantiatedGenericsMacros = new List<(string Name, string Definition)>();
        var genericParameterIndex = 0;
        foreach (var i in shaderBuffers.Context)
        {
            if (i.Op == Op.OpSDSLGenericParameter && (OpSDSLGenericParameter)i is { } genericParameter)
            {
                var genericParameterName = shaderBuffers.Context.Names[genericParameter.ResultId];
                var genericParameterType = shaderBuffers.Context.ReverseTypes[genericParameter.ResultType];
                if (genericParameterType is GenericParameterType { Kind: GenericParameterKindSDSL.MemberName })
                {
                    if (genericResolver.TryResolveGenericValue(genericParameterType, genericParameterName, genericParameterIndex, out var value))
                        instantiatedGenericsMacros.Add((shaderBuffers.Context.Names[genericParameter], value.ToString()));
                }
                genericParameterIndex++;
            }
        }
        foreach (var i in shaderBuffers.Buffer)
        {
            if (i.Op == Op.OpUnresolvableShaderSDSL && (OpUnresolvableShaderSDSL)i is { } unresolvableShader)
            {
                var code = unresolvableShader.ShaderCode;
                if (instantiatedGenericsMacros.Count > 0)
                {
                    // Add something to shaderName (which is used as key in ShaderLoader cache)
                    var originalShaderName = shaderName;
                    shaderName += $"_{string.Join("_", instantiatedGenericsMacros.Select(x => RemoveInvalidCharactersFromSymbol(x.Definition)))}";

                    // Note: we apply the preprocessor only the shader body to transform generics parameter into their actual value without touching the generic definition
                    code = code.Substring(0, unresolvableShader.ShaderCodeNameEnd)
                                // Update shader name for ShaderLoader cache
                                .Replace(originalShaderName, shaderName)
                                // Mark MemberName as resolved
                                .Replace("MemberName ", "MemberNameResolved ")
                        + MonoGamePreProcessor.Run(code.Substring(unresolvableShader.ShaderCodeNameEnd), $"{shaderName}.sdsl", CollectionsMarshal.AsSpan(instantiatedGenericsMacros));
                }

                // TODO: Cache?
                if (!shaderLoader.LoadExternalBuffer(shaderName, code, macros, out shaderBuffers, out _, out _))
                    throw new InvalidOperationException();
            }
        }
    }

    private static void TransformResolvedLinkIdIntoLinkString(SpirvContext context, Dictionary<int, string> resolvedLinks)
    {
        // Try to resolve LinkType generics
        for (var index = 0; index < context.Count; index++)
        {
            var i = context[index];
            if (i.Op == Op.OpDecorate && ((OpDecorate)i) is { Decoration: Decoration.LinkIdSDSL, DecorationParameters: { } m } linkDecorate)
            {
                var n = m.To<DecorationParams.LinkIdSDSL>();
                if (resolvedLinks.TryGetValue(n.IdRef0, out var resolvedValue))
                {
                    context.Replace(index, new OpDecorateString(linkDecorate.Target, Decoration.LinkSDSL, resolvedValue));
                }
            }
            else if (i.Op == Op.OpMemberDecorate && ((OpMemberDecorate)i) is { Decoration: Decoration.LinkIdSDSL, DecorationParameters: { } m2 } linkDecorate2)
            {
                var tmp = new OpMemberDecorate(i);
                var n = m2.To<DecorationParams.LinkIdSDSL>();
                if (resolvedLinks.TryGetValue(n.IdRef0, out var resolvedValue))
                {
                    context.Replace(index, new OpMemberDecorateString(linkDecorate2.StructureType, linkDecorate2.Member, Decoration.LinkSDSL, resolvedValue));
                }
            }
        }
    }

    public static void SetOpNop(Span<int> words)
    {
        words[0] = words.Length << 16;
        words[1..].Clear();
    }

    public static bool ContainIds(HashSet<int> ids, OpData i)
    {
        foreach (var op in i)
        {
            if (op.Kind == OperandKind.IdRef
                 || op.Kind == OperandKind.IdResult
                 || op.Kind == OperandKind.IdResultType
                 || op.Kind == OperandKind.IdScope
                 || op.Kind == OperandKind.IdMemorySemantics
                 || op.Kind == OperandKind.PairIdRefIdRef)
            {
                foreach (var word in op.Words)
                    if (ids.Contains(word))
                        return true;
            }
            else if (op.Kind == OperandKind.PairIdRefLiteralInteger)
            {
                for (int j = 0; j < op.Words.Length; j += 2)
                    if (ids.Contains(op.Words[j]))
                        return true;
            }
            else if (op.Kind == OperandKind.PairLiteralIntegerIdRef)
            {
                for (int j = 1; j < op.Words.Length; j += 2)
                    if (ids.Contains(op.Words[j]))
                        return true;
            }
        }

        return false;
    }

    public static void RemapIds(NewSpirvBuffer buffer, int shaderStart, int shaderEnd, Dictionary<int, int> idRemapping)
    {
        for (var index = shaderStart; index < buffer.Count; index++)
        {
            var i = buffer[index];
            RemapIds(idRemapping, ref i.Data);
        }
    }

    public static void RemapIds(Dictionary<int, int> idRemapping, ref OpData i)
    {
        // Special case: remove OpName and such
        if (i.Op == Op.OpName || i.Op == Op.OpDecorate || i.Op == Op.OpDecorateString
            || i.Op == Op.OpMemberName || i.Op == Op.OpMemberDecorate || i.Op == Op.OpMemberDecorateString)
        {
            // Target/Structure ID is always stored in first operand for all those instructions
            var target = i.Memory.Span[1];
            if (idRemapping.ContainsKey(target))
                SetOpNop(i.Memory.Span);
            return;
        }

        foreach (var op in i)
        {
            if (op.Kind == OperandKind.IdRef
                 || op.Kind == OperandKind.IdResult
                 || op.Kind == OperandKind.IdResultType
                 || op.Kind == OperandKind.IdScope
                 || op.Kind == OperandKind.IdMemorySemantics
                 || op.Kind == OperandKind.PairIdRefIdRef)
            {
                foreach (ref var word in op.Words)
                {
                    if (idRemapping.TryGetValue(word, out var to1))
                        word = to1;
                }

                // Special case: remove duplicates in OpEntryPoint
                if (i.Op == Op.OpEntryPoint && op.Quantifier == OperandQuantifier.ZeroOrMore)
                {
                    var entryPoint = new OpEntryPoint(ref i);

                    var existing = new HashSet<int>();
                    var target = 0;
                    for (int index = 0; index < entryPoint.Values.Elements.Length; ++index)
                    {
                        if (existing.Add(entryPoint.Values.Elements.Span[index]))
                        {
                            entryPoint.Values.Elements.Span[target++] = entryPoint.Values.Elements.Span[index];
                        }
                    }

                    // Slice and reassign to refresh InstructionMemory and size
                    entryPoint.Values = entryPoint.Values.Slice(0, target);
                }
            }

            if (op.Kind == OperandKind.PairIdRefLiteralInteger)
            {
                for (int j = 0; j < op.Words.Length; j += 2)
                {
                    if (idRemapping.TryGetValue(op.Words[j], out var to2))
                        op.Words[j] = to2;
                }
            }

            if (op.Kind == OperandKind.PairLiteralIntegerIdRef)
            {
                for (int j = 1; j < op.Words.Length; j += 2)
                {
                    if (idRemapping.TryGetValue(op.Words[j], out var to2))
                        op.Words[j] = to2;
                }
            }
        }
    }
    
    public static void CollectIds(OpData i, HashSet<int> ids)
    {
        foreach (var op in i)
        {
            if (op.Kind == OperandKind.IdRef
                || op.Kind == OperandKind.IdResult
                || op.Kind == OperandKind.IdResultType
                || op.Kind == OperandKind.IdScope
                || op.Kind == OperandKind.IdMemorySemantics
                || op.Kind == OperandKind.PairIdRefIdRef)
            {
                foreach (var word in op.Words)
                    ids.Add(word);
            }
            else if (op.Kind == OperandKind.PairIdRefLiteralInteger)
            {
                for (int j = 0; j < op.Words.Length; j += 2)
                    ids.Add(op.Words[j]);
            }
            else if (op.Kind == OperandKind.PairLiteralIntegerIdRef)
            {
                for (int j = 1; j < op.Words.Length; j += 2)
                    ids.Add(op.Words[j]);
            }
        }
    }

    /// <summary>
    /// Gets or load a shader, with generic instantiation (if requested).
    /// </summary>
    /// <param name="shaderLoader"></param>
    /// <param name="classSource">The generics parameters should be in <see cref="parentBuffer"/>.</param>
    /// <param name="macros"></param>
    /// <param name="resolveStep"></param>
    /// <returns></returns>
    /// <param name="parentBuffer"></param>
    public static ShaderBuffers GetOrLoadShader(IExternalShaderLoader shaderLoader, ShaderClassInstantiation classSource, ReadOnlySpan<ShaderMacro> macros, ResolveStep resolveStep, SpirvContext context)
    {
        return GetOrLoadShader(shaderLoader, classSource.ClassName, new GenericResolverFromInstantiatingBuffer(classSource, resolveStep, context), macros);
    }

    public static ShaderBuffers GetOrLoadShader(IExternalShaderLoader shaderLoader, string className, string[] genericValues, ReadOnlySpan<ShaderMacro> macros)
    {
        return GetOrLoadShader(shaderLoader, className, new GenericResolverFromValues(genericValues), macros);
    }

    private static ShaderBuffers GetOrLoadShader(IExternalShaderLoader shaderLoader, string className, GenericResolver genericResolver, ReadOnlySpan<ShaderMacro> macros)
    {
        var shaderBuffers = GetOrLoadShader(shaderLoader, className, macros, out var hash, out var isFromCache);

        // Split context and buffer

        // TODO: generics cache?
        if (genericResolver.GenericArgumentCount > 0)
        {
            // First, try to build name for cache lookup
            var classNameWithGenerics = BuildGenericClassName(className, genericResolver);
            var cache = genericResolver.Cache ?? shaderLoader.GenericCache;
            if (shaderLoader.GenericCache.TryLoadFromCache(classNameWithGenerics, macros, out var cachedShaderBuffers, out var cachedHash))
            {
                shaderBuffers = cachedShaderBuffers;
                hash = cachedHash;
            }
            else
            {
                InstantiateMemberNames(ref shaderBuffers, className, genericResolver, shaderLoader, macros);

                // Copy buffers (we don't want to edit original non-instantiated code as it might be reloaded through caching
                shaderBuffers.Context = new SpirvContext(CopyBuffer(shaderBuffers.Context.GetBuffer()))
                {
                    Bound = shaderBuffers.Context.Bound,
                    Names = new(shaderBuffers.Context.Names),
                    Types = new(shaderBuffers.Context.Types),
                    ReverseTypes = new(shaderBuffers.Context.ReverseTypes),
                };
                shaderBuffers.Buffer = CopyBuffer(shaderBuffers.Buffer);

                InstantiateGenericShader(ref shaderBuffers, classNameWithGenerics, genericResolver, shaderLoader, macros);
                shaderLoader.GenericCache.RegisterShader(classNameWithGenerics, macros, shaderBuffers, hash);
            }
            
            // Run in all cases (even if cached)
            genericResolver.PostProcess(classNameWithGenerics);
        }

        return shaderBuffers;
    }

    public static NewSpirvBuffer CopyBuffer(NewSpirvBuffer shader)
    {
        var copiedShader = new NewSpirvBuffer();
        foreach (var i in shader)
        {
            var i2 = new OpData(i.Data.Memory.Span);
            copiedShader.Add(i2);
        }
        shader = copiedShader;
        return shader;
    }

    public static List<int> CollectGenerics(NewSpirvBuffer shader)
    {
        // Collect OpSDSLGenericParameter
        List<int> generics = new();
        for (var index = 0; index < shader.Count; index++)
        {
            var i = shader[index];
            if (i.Op == Op.OpSDSLGenericParameter && (OpSDSLGenericParameter)i is { } genericParameter)
            {
                generics.Add(genericParameter.ResultId);
                SetOpNop(i.Data.Memory.Span);
            }
        }

        return generics;
    }

    public static ShaderBuffers GetOrLoadShader(IExternalShaderLoader shaderLoader, string className, ReadOnlySpan<ShaderMacro> defines, out ObjectId hash, out bool isFromCache)
    {
        //Console.WriteLine($"[Shader] Requesting non-generic class {className}");

        if (!shaderLoader.LoadExternalBuffer(className, defines, out var buffer, out hash, out isFromCache))
            throw new InvalidOperationException($"Could not load shader [{className}]");

        //if (!isFromCache)
        //    Console.WriteLine($"[Shader] Loading non-generic class {className} for 1st time");

        return buffer;
    }
}
