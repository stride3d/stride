using CommunityToolkit.HighPerformance;
using CommunityToolkit.HighPerformance.Buffers;
using Stride.Shaders.Core;
using Stride.Shaders.Parsing;
using Stride.Shaders.Parsing.Analysis;
using Stride.Shaders.Parsing.SDSL;
using Stride.Shaders.Parsing.SDSL.AST;
using Stride.Shaders.Spirv.Core;
using Stride.Shaders.Spirv.Core.Buffers;
using Stride.Shaders.Spirv.Processing;
using Stride.Shaders.Spirv.Tools;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using static Stride.Shaders.Spirv.Specification;

namespace Stride.Shaders.Spirv.Building;

public record class ShaderMixinInstantiation(List<ShaderClassInstantiation> Mixins, Dictionary<string, ShaderMixinInstantiation[]> Compositions);

public record struct ShaderBuffers(SpirvContext Context, NewSpirvBuffer Buffer);

public enum ResolveStep
{
    Compile,
    Mix,
}

public record class ShaderClassInstantiation(string ClassName, int[] GenericArguments, bool ImportStageOnly = false) : IEquatable<ShaderClassInstantiation>
{
    public ShaderBuffers? Buffer { get; set; }

    public string ClassName { get; set; } = ClassName;

    public int[] GenericArguments { get; set; } = GenericArguments;

    public LoadedShaderSymbol Symbol { get; set; }

    public string ToClassName()
    {
        if ((GenericArguments == null || GenericArguments.Length == 0) && !ImportStageOnly)
            return ClassName;

        var result = new StringBuilder();
        result.Append(ClassName);
        if (GenericArguments != null && GenericArguments.Length > 0)
        {
            result.Append('<');
            result.Append(string.Join(",", GenericArguments.Select(x => $"%{x}")));
            result.Append('>');
        }

        return result.ToString();
    }

    public override string ToString() => $"{(ImportStageOnly ? "stage " : string.Empty)}{ToClassName()} Symbol: {Symbol} Buffer: {(Buffer != null ? "set" : "empty")}";

    public virtual bool Equals(ShaderClassInstantiation? shaderClassSource)
    {
        if (shaderClassSource is null) return false;
        if (ReferenceEquals(this, shaderClassSource)) return true;
        return
            string.Equals(ClassName, shaderClassSource.ClassName) &&
            GenericArguments.SequenceEqual(shaderClassSource.GenericArguments);
    }

    public override int GetHashCode()
    {
        unchecked
        {
            int hashCode = ClassName?.GetHashCode() ?? 0;
            if (GenericArguments != null)
            {
                foreach (var current in GenericArguments)
                    hashCode = (hashCode * 397) ^ (current.GetHashCode());
            }

            return hashCode;
        }
    }
}

// Constant vector (generated by TryGetConstantValue)
public class ConstantVector
{
    public object[] Values;

    public override string ToString()
    {
        var type = Values[0] switch
        {
            float => "float",
        };

        return $"{type}{Values.Length}({string.Join(",", Values)})";
    }
}


public partial class SpirvBuilder
{
    public static void BuildInheritanceListWithoutSelf(IExternalShaderLoader shaderLoader, SpirvContext context, ShaderClassInstantiation classSource, ReadOnlySpan<ShaderMacro> macros, NewSpirvBuffer contextBuffer, List<ShaderClassInstantiation> inheritanceList, ResolveStep resolveStep)
    {
        // Build shader name mapping
        var shaderMapping = new Dictionary<int, ShaderClassInstantiation>();
        var genericParameterRemapping = new Dictionary<int, int>();
        foreach (var i in contextBuffer)
        {
            if (i.Op == Op.OpSDSLGenericParameter && (OpSDSLGenericParameter)i is { } genericParameter)
            {
                genericParameterRemapping.Add(genericParameter.ResultId, classSource.GenericArguments[genericParameter.Index]);
            }
            if (i.Op == Op.OpSDSLImportShader && (OpSDSLImportShader)i is { } importShader)
            {
                var shaderClassSource = ConvertToShaderClassSource(contextBuffer, 0, contextBuffer.Count, importShader);

                shaderMapping[importShader.ResultId] = shaderClassSource;
            }
        }

        int RemapGenericParameter(int localGeneric)
        {
            if (genericParameterRemapping.TryGetValue(localGeneric, out var generic))
                return generic;

            // Otherwise, assume it's a constsant we need to import
            var constantBuffer = ExtractConstantAsSpirvBuffer(contextBuffer, localGeneric);
            int index = context.GetBuffer().Count;
            var bound = context.Bound;
            var resultId = InsertBufferWithoutDuplicates(context.GetBuffer(), ref index, ref bound, null, constantBuffer);
            context.Bound = bound;

            return resultId;
        }

        // Check inheritance
        foreach (var i in contextBuffer)
        {
            if (i.Op == Op.OpSDSLMixinInherit && (OpSDSLMixinInherit)i is { } inherit)
            {
                var shaderName = shaderMapping[inherit.Shader];

                // Remap/import generics
                var remappedGenericArguments = shaderName.GenericArguments.ToArray();
                for (int index = 0; index < remappedGenericArguments.Length; index++)
                    remappedGenericArguments[index] = RemapGenericParameter(remappedGenericArguments[index]);

                var remappedShaderName = shaderName with { GenericArguments = remappedGenericArguments };
                BuildInheritanceListIncludingSelf(shaderLoader, context, remappedShaderName, macros, inheritanceList, resolveStep);
            }
        }
    }

    public static ShaderClassInstantiation ConvertToShaderClassSource(NewSpirvBuffer buffer, int shaderStart, int shaderEnd, OpSDSLImportShader importShader)
    {
        return new ShaderClassInstantiation(importShader.ShaderName, importShader.Values.Elements.Memory.ToArray());
    }

    public static ShaderClassInstantiation BuildInheritanceListIncludingSelf(IExternalShaderLoader shaderLoader, SpirvContext context, ShaderClassInstantiation classSource, ReadOnlySpan<ShaderMacro> macros, List<ShaderClassInstantiation> inheritanceList, ResolveStep resolveStep)
    {
        // TODO: cache same instantiations within context?
        var index = inheritanceList.IndexOf(classSource);
        if (index == -1)
        {
            if (classSource.Buffer == null)
            {
                var shader = GetOrLoadShader(shaderLoader, classSource, macros, resolveStep, context);
                classSource.Buffer = shader;
            }

            // Note: since shader instantiation might mutate classSource, perform a search again
            index = inheritanceList.IndexOf(classSource);
            if (index == -1)
            {
                BuildInheritanceListWithoutSelf(shaderLoader, context, classSource, macros, classSource.Buffer.Value.Context.GetBuffer(), inheritanceList, resolveStep);
                index = inheritanceList.Count;
                inheritanceList.Add(classSource);
            }
        }

        return inheritanceList[index];
    }

    public static bool TryGetInstructionById(int constantId, out OpDataIndex instruction, NewSpirvBuffer buffer)
    {
        if (buffer.TryGetInstructionById(constantId, out instruction))
            return true;

        instruction = default;
        return false;
    }

    public static object GetConstantValue(int constantId, NewSpirvBuffer buffer)
    {
        if (buffer.TryGetInstructionById(constantId, out var constant))
        {
            return ResolveConstantValue(constant, buffer);
        }

        throw new Exception("Cannot find constant instruction for id " + constantId);
    }

    public static bool TryGetConstantValue(int constantId, out object value, out int typeId, NewSpirvBuffer buffer, bool simplifyInBuffer = false)
    {
        if (buffer.TryGetInstructionById(constantId, out var constant))
        {
            return TryGetConstantValue(constant, out value, out typeId, buffer, simplifyInBuffer);
        }

        typeId = default;
        value = default;
        return false;
    }

    public static object ResolveConstantValue(OpDataIndex i, NewSpirvBuffer buffer)
    {
        if (!TryGetConstantValue(i, out var value, out _, buffer, false))
            throw new InvalidOperationException($"Can't process constant {i.Data.IdResult}");

        return value;
    }

    // Note: this will return false if constant can't be resolved yet (i.e. due to unresolved generics). If it is not meant to become a constant (even later), behavior is undefined.
    public static bool TryGetConstantValue(OpDataIndex i, out object value, out int typeId, NewSpirvBuffer buffer, bool simplifyInBuffer = false)
    {
        typeId = default;
        value = default;

        // Check for unresolved values
        if (i.Op == Op.OpSDSLGenericParameter || i.Op == Op.OpSDSLGenericReference)
        {
            return false;
        }

        if (i.Op == Op.OpConstantStringSDSL)
        {
            var operand2 = i.Data.Get("literalString");
            value = operand2.ToLiteral<string>();
            return true;
        }

        if (i.Op == Op.OpSpecConstantOp)
        {
            var resultType = i.Data.Memory.Span[1];
            var resultId = i.Data.Memory.Span[2];
            var op = (Op)i.Data.Memory.Span[3];
            switch (op)
            {
                case Op.OpIMul:
                    if (!TryGetConstantValue(i.Data.Memory.Span[4], out var left, out var leftTypeId, buffer))
                        return false;
                    if (!TryGetConstantValue(i.Data.Memory.Span[5], out var right, out var rightTypeId, buffer))
                        return false;
                    if (leftTypeId != resultType || rightTypeId != resultType)
                        return false;
                    value = (int)left * (int)right;
                    if (simplifyInBuffer)
                        buffer.Replace(i.Index, new OpConstant<int>(resultType, resultId, (int)value));
                    return true;
                default:
                    throw new NotImplementedException();
            }
        }
        if ((i.Op == Op.OpConstantComposite || i.Op == Op.OpSpecConstantComposite) &&  (OpConstantComposite)i is { } constantComposite)
        {
            var values = constantComposite.Values;
            var constants = new object[values.WordCount];
            for (int j = 0; j < values.WordCount; ++j)
            {
                if (!TryGetConstantValue(values.Elements.Span[j], out constants[j], out _, buffer))
                    return false;
            }

            // For now we assume it's a vector type (but we would need to revisit that later if we handle more advanced constants such as matrix or arrays)
            value = new ConstantVector { Values = constants };

            return true;
        }

        typeId = i.Op switch
        {
            Op.OpConstant or Op.OpSpecConstant => i.Data.Memory.Span[1],
        };
        var operand = i.Data.Get("value");
        if (buffer.TryGetInstructionById(typeId, out var typeInst))
        {
            if (typeInst.Op == Op.OpTypeInt)
            {
                var type = (OpTypeInt)typeInst;
                value = type switch
                {
                    { Width: <= 32, Signedness: 0 } => operand.ToLiteral<uint>(),
                    { Width: <= 32, Signedness: 1 } => operand.ToLiteral<int>(),
                    { Width: 64, Signedness: 0 } => operand.ToLiteral<ulong>(),
                    { Width: 64, Signedness: 1 } => operand.ToLiteral<long>(),
                    _ => throw new NotImplementedException($"Unsupported int width {type.Width}"),
                };
                return true;
            }
            else if (typeInst.Op == Op.OpTypeFloat)
            {
                var type = new OpTypeFloat(typeInst);
                value = type switch
                {
                    { Width: 16 } => operand.ToLiteral<Half>(),
                    { Width: 32 } => operand.ToLiteral<float>(),
                    { Width: 64 } => operand.ToLiteral<double>(),
                    _ => throw new NotImplementedException($"Unsupported float width {type.Width}"),
                };
                return true;
            }
            else
                throw new NotImplementedException($"Unsupported context dependent number with type {typeInst.Op}");
        }
        throw new Exception("Cannot find type instruction for id " + typeId);
    }

    public static NewSpirvBuffer ExtractConstantAsSpirvBuffer(NewSpirvBuffer buffer, int constantId)
    {
        // First, run a simplification pass
        // TODO: separate simplification from computing value?
        TryGetConstantValue(constantId, out _, out _, buffer, true);

        // Go backward and find any reference
        var newBuffer = new NewSpirvBuffer();
        var referenced = new HashSet<int> { constantId };
        var instructions = new List<OpData>();
        for (int index = buffer.Count - 1; index >= 0; --index)
        {
            var i = buffer[index];
            if (i.Data.IdResult is int resultId && referenced.Remove(resultId))
            {
                var i2 = new OpData(i.Data.Memory.Span);

                // Then add IdRef operands to next requested instructions or types
                foreach (var op in i2)
                {
                    if (op.Kind == OperandKind.IdRef
                        || op.Kind == OperandKind.IdResultType
                        || op.Kind == OperandKind.PairIdRefIdRef)
                    {
                        foreach (ref var word in op.Words)
                        {
                            referenced.Add(word);
                        }
                    }
                    else if (op.Kind == OperandKind.PairLiteralIntegerIdRef
                        || op.Kind == OperandKind.PairIdRefLiteralInteger)
                    {
                        throw new NotImplementedException();
                    }
                }

                instructions.Add(i2);
            }
        }

        // Since we went backward, reverse the list
        instructions.Reverse();
        foreach (var i in instructions)
            newBuffer.Add(i);
        return newBuffer;
    }

    record struct GenericParameter(SymbolType Type, int ResultId, int ResultType, int Index, string Name, bool Resolved, string Value);

    abstract class GenericResolver
    {
        public abstract bool NeedsResolve();

        public abstract bool TryResolveGenericValue(SymbolType genericParameterType, string genericParameterName, int index, out object value);
        public abstract bool ResolveGenericValueInBuffer(SymbolType genericParameterType, string genericParameterName, int genericIndex, SpirvContext context, ref int instructionIndex, out string textValue);

        public virtual void PostProcess(string classNameWithGenerics, List<GenericParameter> genericParameters)
        {
        }
    }

    public static int InsertBufferWithoutDuplicates(NewSpirvBuffer target, ref int instructionIndex, ref int bound, int? desiredResultId, NewSpirvBuffer source)
    {
        // Import in current buffer (without duplicate)
        var typeDuplicateInserter = new TypeDuplicateHelper(target);
        var remapIds = new Dictionary<int, int>();
        int lastResultId = -1;

        var lastResultIndex = -1;
        if (desiredResultId != null)
        {
            // Find last index returning a value (that's the value we want remapped to desiredResultId)
            for (int index = 0; index < source.Count; ++index)
            {
                var i = source[index];
                if (i.Data.IdResult is not null)
                    lastResultIndex = index;
            }
        }

        for (int index = 0; index < source.Count; ++index)
        {
            var i = source[index];
            RemapIds(remapIds, ref i.Data);
            
            //// If it's a generic reference, remap to OpSDSLGenericParameter which has to match during typeDuplicateInserter.CheckForDuplicates()
            var isGenericReference = i.Op == Op.OpSDSLGenericReference;
            if (isGenericReference)
                i.Data.Memory.Span[0] = (int)(i.Data.Memory.Span[0] & 0xFFFF0000) | (int)Op.OpSDSLGenericParameter;

            // Note: we try to avoid duplicating the last (constant) instruction if there is a desired ID (so that it keeps its name/identity) 
            if ((TypeDuplicateHelper.OpCheckDuplicateForTypesAndImport(i.Op) || isGenericReference)
                && typeDuplicateInserter.CheckForDuplicates(i.Data, out var existingData)
                && (index != lastResultIndex || desiredResultId == null))
            {
                // Make sure this data is declared at current index, otherwise move it.
                // Note: it should be safe to do so as the source buffer has all the dependencies and they should have been inserted in previous loops
                if (existingData.Index > instructionIndex)
                {
                    var existingDataCopy = new OpData(existingData.Data.Memory);
                    typeDuplicateInserter.RemoveInstructionAt(existingData.Index, false);
                    existingData = typeDuplicateInserter.InsertInstruction(instructionIndex++, existingDataCopy);
                }
                remapIds.Add(i.Data.IdResult.Value, existingData.Data.IdResult.Value);
                lastResultId = existingData.Data.IdResult.Value;
            }
            else
            {
                if (isGenericReference)
                    i.Data.Memory.Span[0] = (int)(i.Data.Memory.Span[0] & 0xFFFF0000) | (int)Op.OpSDSLGenericReference;

                if (i.Data.IdResult.HasValue)
                {
                    // Make sure to remap last instruction (which we assume is the actual constant) with the desired result ID
                    var resultId = index == lastResultIndex && desiredResultId != null
                        ? desiredResultId.Value
                        : bound++;

                    remapIds.Add(i.Data.IdResult.Value, resultId);
                    i.Data.IdResult = resultId;
                    typeDuplicateInserter.InsertInstruction(instructionIndex++, i.Data);

                    lastResultId = resultId;
                }
            }
        }

        if (lastResultId == -1)
            throw new InvalidOperationException("Could not find any instruction with a value");

        // Note: we made sure to not copy last instruction which should have the constant we want
        if (desiredResultId != null && lastResultId != desiredResultId)
            throw new InvalidOperationException();

        return lastResultId;
    }

    /// <summary>
    /// Instantiate generics using string values (they will be imported in the generic shader being specialized).
    /// </summary>
    class GenericResolverFromValues(string[]? genericValues) : GenericResolver
    {
        public override bool NeedsResolve() => genericValues != null && genericValues.Length > 0;

        public override bool TryResolveGenericValue(SymbolType genericParameterType, string genericParameterName, int index, out object value)
        {
            var genericValue = genericValues![index];
            switch (genericParameterType)
            {
                case ScalarType { TypeName: "int" }:
                    value = int.Parse(genericValue);
                    return true;
                case ScalarType { TypeName: "float" }:
                    value = float.Parse(genericValue);
                    return true;
                case ScalarType { TypeName: "bool" }:
                    value = bool.Parse(genericValue);
                    return true;
                case GenericParameterType g:
                    value = genericValue;
                    return true;
                default:
                    throw new NotImplementedException();
            }
        }

        public override bool ResolveGenericValueInBuffer(SymbolType genericParameterType, string genericParameterName, int genericIndex, SpirvContext context, ref int instructionIndex, out string textValue)
        {
            var contextBuffer = context.GetBuffer();
            var genericParameter = (OpSDSLGenericParameter)contextBuffer[instructionIndex];
            var genericValue = genericValues![genericIndex];
            textValue = genericValue;
            switch (genericParameterType)
            {
                case ScalarType or VectorType:
                    var scanner = new Scanner(textValue);
                    ParseResult pr = new ParseResult();
                    if (!ExpressionParser.Expression(ref scanner, pr, out var expression))
                        throw new InvalidOperationException("Can't parse generic value");
                    var localContext = new SpirvContext();
                    var result = expression.CompileConstantValue(new SymbolTable(localContext), localContext, genericParameterType);
                    contextBuffer.RemoveAt(instructionIndex);
                    var bound = context.Bound;
                    SpirvBuilder.InsertBufferWithoutDuplicates(contextBuffer, ref instructionIndex, ref bound, genericParameter.ResultId, localContext.GetBuffer());
                    context.Bound = bound;
                    instructionIndex--;
                    return true;
                case GenericParameterType g:
                    contextBuffer.Replace(instructionIndex, new OpConstantStringSDSL(genericParameter.ResultId, genericValue));
                    return true;
                default:
                    throw new NotImplementedException();
            }
        }
    }

    /// <summary>
    /// Instantiate generics using another buffer for the shader constants. If a context is specified, constants will be imported there, otherwise inside the generic shader being instantiated.
    /// </summary>
    class GenericResolverFromInstantiatingBuffer(ShaderClassInstantiation classSource, ResolveStep resolveStep, NewSpirvBuffer declaringBuffer) : GenericResolver
    {
        private Dictionary<int, string> names;

        public override bool NeedsResolve() => classSource.GenericArguments.Length > 0;

        private string GetIdRefAsString(int index)
        {
            if (names == null)
                ShaderClass.ProcessNameAndTypes(declaringBuffer, 0, declaringBuffer.Count, out names, out _);

            return names.TryGetValue(classSource.GenericArguments[index], out var genericArgumentName)
                ? $"%{genericArgumentName}[{classSource.GenericArguments[index]}]"
                : $"%{classSource.GenericArguments[index]}";
        }

        public override bool TryResolveGenericValue(SymbolType genericParameterType, string genericParameterName, int index, out object value)
        {
            if (!TryGetConstantValue(classSource.GenericArguments[index], out value, out _, declaringBuffer, false))
            {
                value = GetIdRefAsString(index);
                return false;
            }

            return true;
        }

        public override bool ResolveGenericValueInBuffer(SymbolType genericParameterType, string genericParameterName, int genericIndex, SpirvContext context, ref int instructionIndex, out string textValue)
        {
            var contextBuffer = context.GetBuffer();
            // Check if generic value can already be computed (no OpSDSLGenericParameter and such)
            if (TryGetConstantValue(classSource.GenericArguments[genericIndex], out var constantValue, out _, declaringBuffer, false))
            {
                // TODO: shortcut: store it right away and finish here
                textValue = constantValue.ToString();
            }
            else
            {
                textValue = GetIdRefAsString(genericIndex);
            }

            var genericParameter = (OpSDSLGenericParameter)contextBuffer[instructionIndex];
            var bufferWithConstant = ExtractConstantAsSpirvBuffer(declaringBuffer, classSource.GenericArguments[genericIndex]);

            bool resolved = true;

            // Remap OpSDSLGenericParameter to OpSDSLGenericReference
            for (int index = 0; index < bufferWithConstant.Count; ++index)
            {
                var i = bufferWithConstant[index];

                if (i.Op == Op.OpSDSLGenericParameter && (OpSDSLGenericParameter)i is { } genericParameter2)
                {
                    bufferWithConstant.Replace(index, new OpSDSLGenericReference(genericParameter2.ResultType, genericParameter2.ResultId, genericParameter2.Index, genericParameter2.DeclaringClass));
                    resolved = false;
                }
            }

            contextBuffer.RemoveAt(instructionIndex);

            // TODO: Try to simplify constant
            var bound = contextBuffer.Header.Bound;
            int resultId = InsertBufferWithoutDuplicates(contextBuffer, ref instructionIndex, ref bound, genericParameter.ResultId, bufferWithConstant);
            contextBuffer.Header = contextBuffer.Header with { Bound = bound };

            // Since we removed one instruction earlier, adjust for it so that next loop process just after what has just been added
            instructionIndex--;

            return true;
        }

        public override void PostProcess(string classNameWithGenerics, List<GenericParameter> genericParameters)
        {
            // Fully resolved?
            if (genericParameters.All(x => x.Resolved))
            {
                if (resolveStep == ResolveStep.Mix)
                {
                    classSource.ClassName = classNameWithGenerics;
                    classSource.GenericArguments = [];
                }
            }
            else if (resolveStep == ResolveStep.Mix)
            {
                throw new InvalidOperationException("During mix phase, shaders generics are expected to be fully resolved");
            }
        }
    }

    private static void InstantiateGenericShader(ref ShaderBuffers shaderBuffers, string className, GenericResolver genericResolver, IExternalShaderLoader shaderLoader, ReadOnlySpan<ShaderMacro> macros)
    {
        ShaderClass.ProcessNameAndTypes(shaderBuffers.Context.GetBuffer(), 0, shaderBuffers.Context.GetBuffer().Count, out var names, out var types);

        var resolvedLinks = new Dictionary<int, string>();
        var semantics = new Dictionary<string, string>();

        var genericParameters = new List<GenericParameter>();
        for (int index = 0; index < shaderBuffers.Context.GetBuffer().Count; ++index)
        {
            var i = shaderBuffers.Context.GetBuffer()[index];
            if (i.Op == Op.OpSDSLGenericParameter && (OpSDSLGenericParameter)i is { } genericParameter)
            {
                var genericParameterType = types[genericParameter.ResultType];
                var genericParameterName = names[genericParameter.ResultId];
                var resolved = genericResolver.ResolveGenericValueInBuffer(genericParameterType, genericParameterName, genericParameters.Count, shaderBuffers.Context, ref index, out var textValue);
                genericParameters.Add(new(genericParameterType, genericParameter.ResultId, genericParameter.ResultType, i.Index, genericParameterName, resolved, textValue));

                switch (genericParameterType)
                {
                    case GenericParameterType g when g.Kind is GenericParameterKindSDSL.LinkType:
                        resolvedLinks.Add(genericParameter.ResultId, textValue);
                        break;
                    case GenericParameterType g when g.Kind is GenericParameterKindSDSL.Semantic:
                        semantics.Add(names[genericParameter.ResultId], textValue);
                        break;
                }
            }

            if (i.Op == Op.OpTypeArray && (OpTypeArray)i is { } typeArray)
            {
                // Make sure constant is a proper OpConstant (i.e. not an OpSpecConstant)
                if (!TryGetInstructionById(typeArray.Length, out var lengthInstruction, shaderBuffers.Context.GetBuffer()))
                    throw new InvalidOperationException();
                if (lengthInstruction.Op != Op.OpConstant && TryGetConstantValue(typeArray.Length, out var value, out _, shaderBuffers.Context.GetBuffer(), true))
                {
                }
            }
        }

        Console.WriteLine($"[Shader] Instantiating {className} with values {string.Join(",", genericParameters.Select(x => x.Value))}");

        StringBuilder classNameWithGenericsBuilder = new();
        classNameWithGenericsBuilder.Append(className).Append("<");

        for (int i = 0; i < genericParameters.Count; i++)
        {
            var genericParameter = genericParameters[i];
            var index = genericParameter.Index;
            if (i > 0)
                classNameWithGenericsBuilder.Append(",");
            classNameWithGenericsBuilder.Append(genericParameter.Value.ToString());
        }
        classNameWithGenericsBuilder.Append(">");
        var classNameWithGenerics = classNameWithGenericsBuilder.ToString();

        foreach (var i in shaderBuffers.Buffer)
        {
            if (i.Op == Op.OpSDSLShader && (OpSDSLShader)i is { } shaderDeclaration)
            {
                shaderDeclaration.ShaderName = classNameWithGenerics;
            }
        }

        TransformResolvedSemantics(shaderBuffers.Context.GetBuffer(), semantics);
        TransformResolvedLinkIdIntoLinkString(shaderBuffers.Context.GetBuffer(), resolvedLinks);

        genericResolver.PostProcess(classNameWithGenerics, genericParameters);
    }

    private static void TransformResolvedSemantics(NewSpirvBuffer contextBuffer, Dictionary<string, string> semantics)
    {
        for (var index = 0; index < contextBuffer.Count; index++)
        {
            var i = contextBuffer[index];
            if (i.Op == Op.OpDecorateString && (OpDecorateString)i is { Decoration: { Value: Decoration.UserSemantic, Parameters: { } m } } decorate)
            {
                var n = new LiteralValue<string>(m.Span);
                if (semantics.TryGetValue(n.Value, out var newSemantic))
                {
                    n.Value = newSemantic;
                    decorate.Decoration = new(decorate.Decoration.Value, n.Words);
                }
                n.Dispose();
            }
            else if (i.Op == Op.OpMemberDecorateString && (OpMemberDecorateString)i is { Decoration: { Value: Decoration.UserSemantic, Parameters: { } m2 } } decorate2)
            {
                var n = new LiteralValue<string>(m2.Span);
                if (semantics.TryGetValue(n.Value, out var newSemantic))
                {
                    n.Value = newSemantic;
                    decorate2.Decoration = new(decorate2.Decoration.Value, n.Words);
                }
                n.Dispose();
            }
        }
    }

    private static void InstantiateMemberNames(ref ShaderBuffers shaderBuffers, string shaderName, GenericResolver genericResolver, IExternalShaderLoader shaderLoader, ReadOnlySpan<ShaderMacro> macros)
    {
        bool hasUnresolvableShader = false;
        for (var index = 0; index < shaderBuffers.Buffer.Count; index++)
        {
            var i = shaderBuffers.Buffer[index];
            if (i.Op == Op.OpUnresolvableShaderSDSL && (OpUnresolvableShaderSDSL)i is { } unresolvableShader)
            {
                hasUnresolvableShader = true;
            }
        }

        if (!hasUnresolvableShader)
            return;

        var instantiatedGenericsMacros = new List<(string Name, string Definition)>();
        var genericParameterIndex = 0;
        ShaderClass.ProcessNameAndTypes(shaderBuffers.Context.GetBuffer(), 0, shaderBuffers.Context.GetBuffer().Count, out var names, out var types);
        foreach (var i in shaderBuffers.Context)
        {
            if (i.Op == Op.OpSDSLGenericParameter && (OpSDSLGenericParameter)i is { } genericParameter)
            {
                var genericParameterName = names[genericParameter.ResultId];
                var genericParameterType = types[genericParameter.ResultType];
                if (genericParameterType is GenericParameterType { Kind: GenericParameterKindSDSL.MemberName })
                {
                    if (genericResolver.TryResolveGenericValue(genericParameterType, genericParameterName, genericParameterIndex, out var value))
                        instantiatedGenericsMacros.Add((names[genericParameter], value.ToString()));
                }
                genericParameterIndex++;
            }
        }
        foreach (var i in shaderBuffers.Buffer)
        {
            if (i.Op == Op.OpUnresolvableShaderSDSL && (OpUnresolvableShaderSDSL)i is { } unresolvableShader)
            {
                var code = unresolvableShader.ShaderCode;
                if (instantiatedGenericsMacros.Count > 0)
                {
                    // Add something to shaderName (which is used as key in ShaderLoader cache)
                    var originalShaderName = shaderName;
                    shaderName += $"_{string.Join("_", instantiatedGenericsMacros.Select(x => RemoveInvalidCharactersFromSymbol(x.Definition)))}";

                    // Note: we apply the preprocessor only the shader body to transform generics parameter into their actual value without touching the generic definition
                    code = code.Substring(0, unresolvableShader.ShaderCodeNameEnd)
                                // Update shader name for ShaderLoader cache
                                .Replace(originalShaderName, shaderName)
                                // Mark MemberName as resolved
                                .Replace("MemberName ", "MemberNameResolved ")
                        + MonoGamePreProcessor.Run(code.Substring(unresolvableShader.ShaderCodeNameEnd), $"{shaderName}.sdsl", CollectionsMarshal.AsSpan(instantiatedGenericsMacros));
                }

                if (!shaderLoader.LoadExternalBuffer(shaderName, code, macros, out var shader, out _))
                    throw new InvalidOperationException();

                shaderBuffers = CreateShaderBuffers(shader);
            }
        }
    }

    private static void TransformResolvedLinkIdIntoLinkString(NewSpirvBuffer contextBuffer, Dictionary<int, string> resolvedLinks)
    {
        // Try to resolve LinkType generics
        for (var index = 0; index < contextBuffer.Count; index++)
        {
            var i = contextBuffer[index];
            if (i.Op == Op.OpDecorate && ((OpDecorate)i) is { Decoration: { Value: Decoration.LinkIdSDSL, Parameters: { } m } } linkDecorate)
            {
                using var n = new LiteralValue<int>(m.Span);
                if (resolvedLinks.TryGetValue(n.Value, out var resolvedValue))
                {
                    contextBuffer.Replace(index, new OpDecorateString(linkDecorate.Target, new ParameterizedFlag<Decoration>(Decoration.LinkSDSL, [.. resolvedValue.AsDisposableLiteralValue().Words])));
                }
            }
            else if (i.Op == Op.OpMemberDecorate && ((OpMemberDecorate)i) is { Decoration: { Value: Decoration.LinkIdSDSL, Parameters: { } m2 } } linkDecorate2)
            {
                using var n = new LiteralValue<int>(m2.Span);
                if (resolvedLinks.TryGetValue(n.Value, out var resolvedValue))
                {
                    contextBuffer.Replace(index, new OpMemberDecorateString(linkDecorate2.StructureType, linkDecorate2.Member, new ParameterizedFlag<Decoration>(Decoration.LinkSDSL, [.. resolvedValue.AsDisposableLiteralValue().Words])));
                }
            }
        }
    }

    public static void SetOpNop(Span<int> words)
    {
        words[0] = words.Length << 16;
        words[1..].Clear();
    }

    public static bool ContainIds(HashSet<int> ids, OpData i)
    {
        foreach (var op in i)
        {
            if ((op.Kind == OperandKind.IdRef
                 || op.Kind == OperandKind.IdResult
                 || op.Kind == OperandKind.IdResultType
                 || op.Kind == OperandKind.PairIdRefLiteralInteger
                 || op.Kind == OperandKind.PairIdRefIdRef)
                && op.Words.Length > 0
                && ids.Contains(op.Words[0]))
            {
                return true;
            }

            if ((op.Kind == OperandKind.PairLiteralIntegerIdRef
                 || op.Kind == OperandKind.PairIdRefIdRef)
                && ids.Contains(op.Words[1]))
            {
                return true;
            }
        }

        return false;
    }

    public static void RemapIds(NewSpirvBuffer buffer, int shaderStart, int shaderEnd, Dictionary<int, int> idRemapping)
    {
        for (var index = shaderStart; index < buffer.Count; index++)
        {
            var i = buffer[index];
            RemapIds(idRemapping, ref i.Data);
        }
    }

    public static void RemapIds(Dictionary<int, int> idRemapping, ref OpData i)
    {
        // Special case: remove OpName and such
        if (i.Op == Op.OpName || i.Op == Op.OpDecorate || i.Op == Op.OpDecorateString
            || i.Op == Op.OpMemberName || i.Op == Op.OpMemberDecorate || i.Op == Op.OpMemberDecorateString)
        {
            // Target/Structure ID is always stored in first operand for all those instructions
            var target = i.Memory.Span[1];
            if (idRemapping.ContainsKey(target))
                SetOpNop(i.Memory.Span);
            return;
        }

        foreach (var op in i)
        {
            if ((op.Kind == OperandKind.IdRef
                 || op.Kind == OperandKind.IdResult
                 || op.Kind == OperandKind.IdResultType
                 || op.Kind == OperandKind.PairIdRefLiteralInteger
                 || op.Kind == OperandKind.PairIdRefIdRef))
            {
                foreach (ref var word in op.Words)
                {
                    if (idRemapping.TryGetValue(word, out var to1))
                        word = to1;
                }

                // Special case: remove duplicates in OpEntryPoint
                if (i.Op == Op.OpEntryPoint && op.Quantifier == OperandQuantifier.ZeroOrMore)
                {
                    var entryPoint = new OpEntryPoint(ref i);

                    var existing = new HashSet<int>();
                    var target = 0;
                    for (int index = 0; index < entryPoint.Values.Elements.Length; ++index)
                    {
                        if (existing.Add(entryPoint.Values.Elements.Span[index]))
                        {
                            entryPoint.Values.Elements.Span[target++] = entryPoint.Values.Elements.Span[index];
                        }
                    }

                    // Slice and reassign to refresh InstructionMemory and size
                    entryPoint.Values = entryPoint.Values.Slice(0, target);
                }
            }

            if ((op.Kind == OperandKind.PairIdRefLiteralInteger)
                && idRemapping.TryGetValue(op.Words[0], out var to2))
            {
                if (op.Quantifier != OperandQuantifier.One)
                    throw new NotImplementedException();
                op.Words[0] = to2;
            }

            if ((op.Kind == OperandKind.PairLiteralIntegerIdRef
                 || op.Kind == OperandKind.PairIdRefIdRef)
                && idRemapping.TryGetValue(op.Words[1], out var to3))
            {
                if (op.Quantifier != OperandQuantifier.One)
                    throw new NotImplementedException();
                op.Words[1] = to3;
            }
        }
    }

    /// <summary>
    /// Gets or load a shader, with generic instantiation (if requested).
    /// </summary>
    /// <param name="shaderLoader"></param>
    /// <param name="classSource">The generics parameters should be in <see cref="parentBuffer"/>.</param>
    /// <param name="macros"></param>
    /// <param name="resolveStep"></param>
    /// <returns></returns>
    /// <param name="parentBuffer"></param>
    public static ShaderBuffers GetOrLoadShader(IExternalShaderLoader shaderLoader, ShaderClassInstantiation classSource, ReadOnlySpan<ShaderMacro> macros, ResolveStep resolveStep, SpirvContext context)
    {
        return GetOrLoadShader(shaderLoader, classSource.ClassName, new GenericResolverFromInstantiatingBuffer(classSource, resolveStep, context.GetBuffer()), macros);
    }

    public static ShaderBuffers GetOrLoadShader(IExternalShaderLoader shaderLoader, ShaderClassInstantiation classSource, ReadOnlySpan<ShaderMacro> macros, ResolveStep resolveStep, NewSpirvBuffer declaringBuffer)
    {
        return GetOrLoadShader(shaderLoader, classSource.ClassName, new GenericResolverFromInstantiatingBuffer(classSource, resolveStep, declaringBuffer), macros);
    }

    public static ShaderBuffers GetOrLoadShader(IExternalShaderLoader shaderLoader, string className, string[] genericValues, ReadOnlySpan<ShaderMacro> macros)
    {
        return GetOrLoadShader(shaderLoader, className, new GenericResolverFromValues(genericValues), macros);
    }

    private static ShaderBuffers GetOrLoadShader(IExternalShaderLoader shaderLoader, string className, GenericResolver genericResolver, ReadOnlySpan<ShaderMacro> macros)
    {
        var shader = GetOrLoadShader(shaderLoader, className, macros, out var isFromCache);

        var shaderBuffers = CreateShaderBuffers(shader);

        // Split context and buffer

        //if (!isFromCache)
        //    Spv.Dis(shader, DisassemblerFlags.Name | DisassemblerFlags.Id | DisassemblerFlags.InstructionIndex, true);

        if (genericResolver.NeedsResolve())
        {
            InstantiateMemberNames(ref shaderBuffers, className, genericResolver, shaderLoader, macros);

            shaderBuffers.Context = new SpirvContext(CopyBuffer(shaderBuffers.Context.GetBuffer())) { Bound = shader.Header.Bound };
            shaderBuffers.Buffer = CopyBuffer(shaderBuffers.Buffer);

            InstantiateGenericShader(ref shaderBuffers, className, genericResolver, shaderLoader, macros);
            //Spv.Dis(shader, DisassemblerFlags.Name | DisassemblerFlags.Id | DisassemblerFlags.InstructionIndex, true);

            shaderBuffers.Context.GetBuffer().Header = shaderBuffers.Context.GetBuffer().Header with { Bound = shaderBuffers.Context.Bound };
            shaderBuffers.Buffer.Header = shaderBuffers.Buffer.Header with { Bound = shaderBuffers.Context.Bound };
        }

        return shaderBuffers;
    }

    private static ShaderBuffers CreateShaderBuffers(NewSpirvBuffer shader)
    {
        var context = new SpirvContext();
        var buffer = new NewSpirvBuffer();
        var isContext = true;
        foreach (var i in shader)
        {
            // Find when switching from context to actual shader/effect
            if (i.Op == Op.OpSDSLShader || i.Op == Op.OpSDSLEffect)
                isContext = false;

            if (isContext)
                context.GetBuffer().Add(i.Data);
            else
                buffer.Add(i.Data);
        }

        context.GetBuffer().Header = shader.Header;
        buffer.Header = shader.Header;

        context.Bound = shader.Header.Bound;

        var shaderBuffers = new ShaderBuffers(context, buffer);
        return shaderBuffers;
    }

    public static NewSpirvBuffer CopyBuffer(NewSpirvBuffer shader)
    {
        var copiedShader = new NewSpirvBuffer();
        foreach (var i in shader)
        {
            var i2 = new OpData(i.Data.Memory.Span);
            copiedShader.Add(i2);
        }
        shader = copiedShader;
        return shader;
    }

    public static List<int> CollectGenerics(NewSpirvBuffer shader)
    {
        // Collect OpSDSLGenericParameter
        List<int> generics = new();
        for (var index = 0; index < shader.Count; index++)
        {
            var i = shader[index];
            if (i.Op == Op.OpSDSLGenericParameter && (OpSDSLGenericParameter)i is { } genericParameter)
            {
                generics.Add(genericParameter.ResultId);
                SetOpNop(i.Data.Memory.Span);
            }
        }

        return generics;
    }

    public static NewSpirvBuffer GetOrLoadShader(IExternalShaderLoader shaderLoader, string className, ReadOnlySpan<ShaderMacro> defines, out bool isFromCache)
    {
        Console.WriteLine($"[Shader] Requesting non-generic class {className}");

        if (!shaderLoader.LoadExternalBuffer(className, defines, out var buffer, out isFromCache))
            throw new InvalidOperationException($"Could not load shader [{className}]");

        if (!isFromCache)
            Console.WriteLine($"[Shader] Loading non-generic class {className} for 1st time");

        return buffer;
    }
}
