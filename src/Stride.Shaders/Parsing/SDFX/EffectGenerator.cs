using Stride.Core.Shaders.Utility;
using Stride.Shaders.Core;
using Stride.Shaders.Parsing.SDFX.AST;
using Stride.Shaders.Parsing.SDSL.AST;

namespace Stride.Shaders.Parsing.SDFX;

public class EffectGenerator : ShaderWriter
{
    private readonly LoggerResult logging = new();
    private Stack<ShaderBlockContext> contextStack = new();
    private Dictionary<BlockStatement, ShaderBlockContext> blockContexts = new();
    private BlockStatement currentBlock;

    private bool IsParameterDeclaredInContext(string parameter)
    {
        foreach (var context in contextStack)
        {
            if (context.DeclaredParameters.Contains(parameter))
                return true;
        }

        return false;
    }
    
    public bool Run(Node node)
    {
        void LogErrors()
        {
            foreach (var reportMessage in logging.Messages)
            {
                if (reportMessage.Level == ReportMessageLevel.Error)
                {
                    Write("#error ").WriteLine(reportMessage.ToString());
                }
            }
        }
        
        var blockVisitor = new ShaderBlockVisitor(this, logging);
        blockVisitor.VisitNode(node);

        if (logging.HasErrors)
        {
            LogErrors();
            return false;
        }
        
        WriteLine("// <auto-generated>");
        WriteLine("// Do not edit this file yourself!");
        WriteLine("//");
        WriteLine("// This code was generated by Stride Shader Mixin Code Generator.");
        WriteLine("// To generate it yourself, please install Stride.VisualStudio.Package .vsix");
        WriteLine("// and re-save the associated .sdfx.");
        WriteLine("// </auto-generated>");
        WriteLine();

        // No mixin found, just return
        if (!blockVisitor.HasMixin && !blockVisitor.HasShaderClassType)
        {
            WriteLine("// Nothing to generate");
            return true;
        }

        // Header of usings declaration
        // TODO: Should probably be better to use fully qualified name of types to avoid conflicts.

        WriteLine("using System;");
        WriteLine("using Stride.Core;");
        WriteLine("using Stride.Rendering;");
        WriteLine("using Stride.Graphics;");
        WriteLine("using Stride.Shaders;");
        WriteLine("using Stride.Core.Mathematics;");
        WriteLine("using Buffer = Stride.Graphics.Buffer;");
        WriteLine();

        // Visit the shader and generate the code
        VisitNode(node);

        // If there are any errors log them into the shader
        if (logging.HasErrors)
        {
            LogErrors();
            return false;
        }

        return true;
    }
    
    public override void VisitShaderEffect(ShaderEffect shaderEffect)
    {
        Write("internal static partial class ShaderMixins");
        {
            OpenBrace();
            Write("internal partial class");
            Write(" ");
            Write(shaderEffect.Name);
            WriteSpace();
            Write(" : IShaderMixinBuilder");
            {
                OpenBrace();
                // Generate the main generate method for each shader block
                Write("public void Generate(ShaderMixinSource mixin, ShaderMixinContext context)");
                {
                    VisitNode(shaderEffect.Block);
                }

                WriteLine();
                WriteLine("[System.Runtime.CompilerServices.ModuleInitializer]");
                WriteLine("internal static void __Initialize__()");
                {
                    OpenBrace();
                    Write("ShaderMixinManager.Register(\"").Write(shaderEffect.Name).Write("\", new ").Write(shaderEffect.Name).WriteLine("());");
                    CloseBrace();
                }
                CloseBrace();
            }
            CloseBrace();
        }
    }

    public override void VisitBlockStatement(BlockStatement blockStatement)
    {
        contextStack.Push(new ShaderBlockContext());
        base.VisitBlockStatement(blockStatement);
        contextStack.Pop();
    }

    public override void VisitUsingShaderNamespace(UsingShaderNamespace usingShaderNamespace)
    {
        Write("using ").Write(string.Join('.', usingShaderNamespace.NamespacePath)).WriteLine(";");
    }

    public override void VisitShaderNamespace(ShaderNamespace shaderNamespace)
    {
        Write("namespace ").Write(string.Join(".", shaderNamespace.NamespacePath));
        OpenBrace();
        foreach (var node in shaderNamespace.Declarations)
        {
            VisitNode(node);
        }
        CloseBrace();
    }

    public override void VisitAssign(Assign assign)
    {
        if (assign.Variables.Count == 1
            && assign.Variables[0].Value is not null
            && TryParameters(assign.Variables[0].Variable, out var typeTarget, out var typeMember))
        {
            Write("context.SetParam(").Write(typeTarget).Write(".").Write(typeMember.ToString()).Write(", ");
            VisitNode(assign.Variables[0].Value);
            Write(")");
        }
        else
        {
            base.VisitAssign(assign);
        }
    }

    public override void VisitAccessorChainExpression(AccessorChainExpression accessorChainExpression)
    {
        if (TryParameters(accessorChainExpression, out var typeTarget, out var typeMember))
        {
            var key = typeTarget + "." + typeMember;
            Write("context.GetParam(").Write(typeTarget).Write(".").Write(typeMember.ToString()).Write(")");
        }
        else
        {
            base.VisitAccessorChainExpression(accessorChainExpression);
        }
    }
    
    private bool TryParameters(Expression expression, out string type, out string member)
    {
        type = null;
        member = null;
        var accessorChainExpression = expression as AccessorChainExpression;
        if (accessorChainExpression == null || accessorChainExpression.Accessors.Count != 1 || !(accessorChainExpression.Source is ExternalShaderAccess accessMember))
            return false;

        var name = accessorChainExpression.Source.ToString();

        bool foundDeclaredParameters = false;
        if (IsParameterDeclaredInContext(name))
        {
            type = name;
            member = accessMember.ToString();
            foundDeclaredParameters = true;
        }

        return foundDeclaredParameters;
    }


    private void ExtractGenericParameters(Expression mixinStatementValue, out Expression mixinName, out ShaderExpressionList? genericParameters)
    {
        if (mixinStatementValue is GenericIdentifier genericIdentifier)
        {
            mixinName = genericIdentifier.Name;
            genericParameters = genericIdentifier.Generics;
        }
        else
        {
            mixinName = mixinStatementValue;
            genericParameters = null;
        }
    }

    private void WriteGenericParameters(ShaderExpressionList? genericParameters)
    {
        if (genericParameters != null)
        {
            foreach (var genericParameter in genericParameters)
            {
                Write(", ");
                VisitNode(genericParameter);
            }
        }
    }
    
    public override void VisitMixin(Mixin mixinStatement)
    {
        switch (mixinStatement.Type)
        {
            case MixinStatementType.Default:
            {
                ExtractGenericParameters(mixinStatement.Value, out var mixinName, out var genericParameters);

                WriteLinkLine(mixinStatement);
                Write("context.Mixin(mixin, ");
                WriteMixinName(mixinName);
                WriteGenericParameters(genericParameters);
                WriteLine(");");
                break;
            }
            case MixinStatementType.Child:
            {
                // mixin child can come in 2 flavour:
                // 1) mixin child MyEffect
                //    => equivalent to 2) with "mixin child MyEffect = MyEffect"
                // 2) mixin child MyGenericEffectName = MyEffect
                ExtractGenericParameters(mixinStatement.Value, out var mixinName, out var genericParameters);
                var childName = mixinStatement.Target ?? (Identifier)mixinStatement.Value;
                {
                    WriteLinkLine(mixinStatement);
                    Write("if (context.ChildEffectName == ");
                    WriteMixinName(childName);
                    Write(")");
                    OpenBrace();

                    WriteLinkLine(mixinStatement);
                    Write("context.Mixin(mixin, ");
                    WriteMixinName(mixinName);
                    WriteGenericParameters(genericParameters);
                    WriteLine(");");
                    WriteLine("return;");

                    CloseBrace();
                }
                break;
            }
            case MixinStatementType.Remove:
            {
                ExtractGenericParameters(mixinStatement.Value, out var mixinName, out var genericParameters);
                
                WriteLinkLine(mixinStatement);
                Write("context.RemoveMixin(mixin, ");
                WriteMixinName(mixinName);
                WriteGenericParameters(genericParameters);
                WriteLine(");");
                break;
            }
            case MixinStatementType.Macro:
            {
                WriteLinkLine(mixinStatement);
                string macroName;
                Expression macroValue;

                if (mixinStatement.Target != null)
                {
                    macroName = mixinStatement.Target;
                    macroValue = mixinStatement.Value;
                }
                else
                {
                    var variableReference = mixinStatement.Value as AccessorChainExpression;
                    if (variableReference == null || !(variableReference.Source is Identifier id) || !IsParameterDeclaredInContext(id.Name))
                    {
                        logging.Error("Invalid syntax. Expecting: mixin macro Parameters.NameOfProperty or mixin macro nameOfProperty = value", mixinStatement.Info);
                        macroName = "#INVALID_MACRO_NAME";
                        macroValue = mixinStatement.Value;
                    }
                    else
                    {
                        macroName = ((Identifier)variableReference.Accessors[0]).Name;
                        macroValue = mixinStatement.Value;
                    }
                }

                Write("mixin.AddMacro(");
                Write(macroName);
                Write(", ");
                VisitNode(macroValue);
                WriteLine(");");
                break;
            }
            case MixinStatementType.ComposeSet:
            case MixinStatementType.ComposeAdd:
            {
                if (mixinStatement.Target == null)
                {
                    logging.Error("Expecting assign expression for composition", mixinStatement.Value.Info);
                    return;
                }

                var addCompositionFunction = "PushComposition";

                // If it's a +=, let's create or complete a ShaderArraySource
                if (mixinStatement.Type == MixinStatementType.ComposeAdd)
                {
                    addCompositionFunction = "PushCompositionArray";
                }
                
                ExtractGenericParameters(mixinStatement.Value, out var mixinName, out var genericParameters);

                OpenBrace();
                WriteLinkLine(mixinStatement);
                Write("var __mixinToCompose__ = ");
                WriteMixinName(mixinName);
                WriteLine(";");
                WriteLine("var __subMixin = new ShaderMixinSource();");

                WriteLinkLine(mixinStatement);
                Write("context.").Write(addCompositionFunction).Write("(mixin, ");
                WriteStringOrExpression(mixinStatement.Target);
                WriteLine(", __subMixin);");

                WriteLinkLine(mixinStatement);
                Write("context.Mixin(__subMixin, __mixinToCompose__");
                WriteGenericParameters(genericParameters);
                WriteLine(");");

                WriteLinkLine(mixinStatement);
                WriteLine("context.PopComposition();");
                CloseBrace();
                break;
            }
        }
    }
    
    private void WriteMixinName(Expression mixinName)
    {
        WriteStringOrExpression(mixinName);
    }
    
    private void WriteStringOrExpression(Expression expr)
    {
        // Output between "" only if the mixin name is only a variable
        if (expr is Identifier)
            Write("\"");
        VisitNode(expr);
        if (expr is Identifier)
            Write("\"");
    }

    public override void VisitUsingParams(UsingParams usingParametersStatement)
    {
        if (contextStack.Count == 0)
        {
            logging.Error("Unexpected 'using params' outside of shader block declaration", usingParametersStatement.Info);
            return;
        }

        var currentContext = contextStack.Peek();
        HashSet<string> usings = currentContext.DeclaredParameters;

        var typeName = usingParametersStatement.ParamsName.Name;
        if (usings.Contains(typeName))
        {
            logging.Error("Unexpected declaration of using params. This variable is already declared in this scope", usingParametersStatement.Info);
            return;
        }

        usings.Add(typeName);
    }
    
    public override void VisitShaderClass(ShaderClass shaderClass)
    {
        // Skip shaders
    }
    
    public override void VisitEffectParameters(EffectParameters effectParameters)
    {
        Write("[DataContract]");
        WriteLinkLine(effectParameters);
        Write("public partial class");
        Write(" ");
        Write(effectParameters.Name);
        WriteSpace();
        Write(": ShaderMixinParameters");
        {
            OpenBrace();

            foreach (var parameter in effectParameters.Parameters)
            {
                WriteLinkLine(parameter);
                VisitNode(parameter.Type);
                WriteSpace();
                VisitNode(parameter.Identifier);
                if (parameter.DefaultValue != null)
                    throw new NotImplementedException();
                WriteLine(";");
            }

            CloseBrace(false).Write(";").WriteLine();
        }
    }
    
    internal bool IsParameterKey(ShaderElement element)
    {
        if (element is not (ShaderVariable or ShaderMember)) return false;

        var storageClass = element switch
        {
            ShaderVariable v => v.StorageClass,
            ShaderMember m => m.StorageClass,
        };
        
        // TODO:
        // Don't generate a parameter key for variable stored storage qualifier: extern, const, compose, stream
        //if (variable.Qualifiers.Contains(HlslStorageQualifier.Extern) ||
        //    variable.Qualifiers.Contains(StorageQualifier.Const) ||
        //    variable.Qualifiers.Contains(StrideStorageQualifier.Compose) ||
        //    variable.Qualifiers.Contains(StrideStorageQualifier.PatchStream) ||
        //    variable.Qualifiers.Contains(StorageQualifier.GroupShared) ||
        //    variable.Qualifiers.Contains(StrideStorageQualifier.Stream))
        //    return false;
        //
        //// Don't generate a parameter key for [Link] or [RenameLink]
        //if (variable.Attributes.OfType<AttributeDeclaration>().Any(x => x.Name == "RenameLink" || x.Name == "Link"))
        //    return false;
        
        return true;
    }
    
    private class ShaderBlockContext
    {
        public readonly HashSet<string> DeclaredParameters = new HashSet<string>();
    }
    
    /// <summary>
    /// Internal visitor to precalculate all available Parameters in the context
    /// </summary>
    private sealed class ShaderBlockVisitor : NodeWalker
    {
        private readonly LoggerResult logging;
        private ShaderBlockContext currentContext;

        private readonly EffectGenerator parent;

        public ShaderBlockVisitor(EffectGenerator parent, LoggerResult logging)
        {
            this.parent = parent;
            this.logging = logging;
        }

        public bool HasMixin { get; private set; }

        public bool HasShaderClassType { get; private set; }

        public override void VisitEffectParameters(EffectParameters paramsBlock)
        {
            HasMixin = true;
        }

        public override void VisitShaderClass(ShaderClass shaderClassType)
        {
            // Check if there are any parameter keys in ShaderClassType and ConstantBuffer
            CheckParameterKeys(shaderClassType.Elements.OfType<ShaderVariable>());
            CheckParameterKeys(shaderClassType.Elements.OfType<CBuffer>().SelectMany(cbuffer => cbuffer.Members));
        }

        private void CheckParameterKeys(IEnumerable<ShaderElement> variables)
        {
            foreach (var variable in variables)
            {
                if (!HasShaderClassType)
                {
                    if (parent.IsParameterKey(variable))
                    {
                        HasShaderClassType = true;
                    }
                }
            }
        }
    }
}