using Stride.Shaders.Core;
using Stride.Shaders.Parsing.Analysis;
using Stride.Shaders.Parsing.SDFX.AST;
using Stride.Shaders.Parsing.SDSL.AST;
using Stride.Shaders.Spirv;
using Stride.Shaders.Spirv.Building;

namespace Stride.Shaders.Parsing.SDFX;

public class EffectCodeWriter : ShaderWriter
{
    private const string DefaultNameSpace = "Stride.Rendering";
    
    private readonly List<(string Message, TextLocation Location)> logging = new();
    private Stack<ShaderBlockContext> contextStack = new();
    private Dictionary<BlockStatement, ShaderBlockContext> blockContexts = new();
    private BlockStatement currentBlock;
    private SymbolTable table = new(new()) { ResolveArraySizes = false, ResolveExternalTypes = false };

    private bool isProcessingColor = false;
    
    public bool Run(Node node)
    {
        void LogErrors()
        {
            foreach (var reportMessage in logging)
            {
                Write("#error ").WriteLine(reportMessage.ToString());
            }
        }
        
        var blockVisitor = new ShaderBlockVisitor(this);
        blockVisitor.VisitNode(node);

        if (logging.Count > 0)
        {
            LogErrors();
            return false;
        }

        WriteLine("// <auto-generated>");
        WriteLine("// Do not edit this file yourself!");
        WriteLine("//");
        WriteLine("// This code was generated by Stride Shader Mixin Code Generator.");
        WriteLine("// To generate it yourself, please install Stride.VisualStudio.Package .vsix");
        WriteLine("// and re-save the associated .sdfx.");
        WriteLine("// </auto-generated>");
        WriteLine();

        // No mixin found, just return
        if (!blockVisitor.HasMixin && !blockVisitor.HasShaderClassType)
        {
            WriteLine("// Nothing to generate");
            return true;
        }

        // Header of usings declaration
        // TODO: Should probably be better to use fully qualified name of types to avoid conflicts.

        WriteLine("using System;");
        WriteLine("using Stride.Core;");
        WriteLine("using Stride.Rendering;");
        WriteLine("using Stride.Graphics;");
        WriteLine("using Stride.Shaders;");
        WriteLine("using Stride.Core.Mathematics;");
        WriteLine("using Buffer = Stride.Graphics.Buffer;");
        WriteLine();

        // Visit the shader and generate the code
        VisitNode(node);

        // If there are any errors log them into the shader
        if (logging.Count > 0)
        {
            LogErrors();
            return false;
        }

        return true;
    }

    public override void VisitShaderStruct(ShaderStruct shaderStruct)
    {
        // Register struct in table
        shaderStruct.ProcessSymbol(table, table.Context);
    }
    
    protected void WriteVariableAsParameterKey(bool isSdfx, TypeName typeName, Identifier name, Expression? initialValue, List<ShaderAttribute> attributes)
    {
        isProcessingColor = attributes.OfType<AnyShaderAttribute>().Any(x => x.Name == "Color");
        var isArray = false;

        var variableType = attributes.OfType<AnyShaderAttribute>().Where(x => x.Name == "Type").Select(x => ((StringLiteral)x.Parameters[0]).Value).FirstOrDefault();
        var variableMap = attributes.OfType<AnyShaderAttribute>().Where(x => x.Name == "Map").Select(x => ((StringLiteral)x.Parameters[0]).Value).FirstOrDefault();

        typeName.ProcessSymbol(table);
        var type = typeName.Type;
        
        // ParameterKey shouldn't contain only the underlying type in case of arrays (we use slots)
        var parameterType = type;

        string parameterKeyType;
        if (isSdfx)
        {
            parameterKeyType = "Permutation";
        }
        else
        {
            
            while (parameterType is ArrayType a)
            {
                parameterType = a.BaseType;
            }

            if (parameterType is ShaderSymbol or TextureType or BufferType or StructuredBufferType or SamplerType)
            {
                parameterKeyType = "Object";
            }
            else
            {
                parameterKeyType = "Value";
            }
        }

        Write($"public static readonly {parameterKeyType}ParameterKey<");
        if (variableType == null)
            VisitNode(new TypeName(parameterType.ToString(), default) { Type = parameterType });
        else
            Write(variableType);
        Write("> ");
        Write(name);
        Write(" = ");
        if (variableMap == null)
        {
            Write($"ParameterKeys.New{parameterKeyType}<");
            if (variableType == null)
                VisitNode(new TypeName(parameterType.ToString(), default) { Type = parameterType });
            else
                Write(variableType);
            Write(">(");
            if (initialValue != null)
            {
                var initialValueString = initialValue.ToString();

                if (initialValueString != "null")
                {
                    var initialValueType = type.ToId();

                    if (type is ArrayType)
                        initialValueString = initialValueType + initialValueString;

                    // Rename float2/3/4 to Vector2/3/4
                    if (initialValueString.StartsWith("float2", StringComparison.Ordinal) ||
                        initialValueString.StartsWith("float3", StringComparison.Ordinal) ||
                        initialValueString.StartsWith("float4", StringComparison.Ordinal))
                    {
                        initialValueString = initialValueString.Replace("float", "new Vector");
                    }
                    else if (type is ArrayType)
                    {
                        initialValueString = "new " + initialValueType;
                    }
                    if (isProcessingColor)
                    {
                        initialValueString = initialValueString.Replace("Vector3", "Color3");
                        initialValueString = initialValueString.Replace("Vector4", "Color4");
                    }
                }
                Write(initialValueString);
            }
            Write(")");
        }
        else
        {
            Write(variableMap);
        }
        WriteLine(";");

        isProcessingColor = false;
    }

    private bool IsParameterDeclaredInContext(string parameter)
    {
        foreach (var context in contextStack)
        {
            if (context.DeclaredParameters.Contains(parameter))
                return true;
        }

        return false;
    }

    public override void VisitShaderEffect(ShaderEffect shaderEffect)
    {
        WriteLine("internal static partial class ShaderMixins");
        {
            OpenBrace();
            Write("internal partial class");
            Write(" ");
            Write(shaderEffect.Name);
            WriteSpace();
            WriteLine(" : IShaderMixinBuilder");
            {
                OpenBrace();
                // Generate the main generate method for each shader block
                WriteLine("public void Generate(ShaderMixinSource mixin, ShaderMixinContext context)");
                {
                    VisitNode(shaderEffect.Block);
                }

                WriteLine();
                WriteLine("[System.Runtime.CompilerServices.ModuleInitializer]");
                WriteLine("internal static void __Initialize__()");
                {
                    OpenBrace();
                    Write("ShaderMixinManager.Register(\"").Write(shaderEffect.Name).Write("\", new ").Write(shaderEffect.Name).WriteLine("());");
                    CloseBrace();
                }
                CloseBrace();
            }
            CloseBrace();
        }
    }

    public override void VisitShaderMember(ShaderMember shaderMember)
    {
        // Do nothing
        if (IsParameterKey(shaderMember))
            WriteVariableAsParameterKey(false, shaderMember.TypeName, shaderMember.Name, shaderMember.Value, shaderMember.Attributes ?? []);
    }

    public override void VisitShaderSamplerState(ShaderSamplerState shaderSamplerState)
    {
        // Do nothing
        if (IsParameterKey(shaderSamplerState))
            WriteVariableAsParameterKey(false, new TypeName("SamplerState", default), shaderSamplerState.Name, null, shaderSamplerState.Attributes ?? []);
    }

    public override void VisitShaderSamplerComparisonState(ShaderSamplerComparisonState shaderSamplerState)
    {
        // Do nothing
        if (IsParameterKey(shaderSamplerState))
            WriteVariableAsParameterKey(false, new TypeName("SamplerState", default), shaderSamplerState.Name, null, shaderSamplerState.Attributes ?? []);
    }
    
    public override void VisitBlockStatement(BlockStatement blockStatement)
    {
        contextStack.Push(new ShaderBlockContext());
        base.VisitBlockStatement(blockStatement);
        contextStack.Pop();
    }

    public override void VisitUsingShaderNamespace(UsingShaderNamespace usingShaderNamespace)
    {
        Write("using ").Write(string.Join('.', usingShaderNamespace.NamespacePath)).WriteLine(";");
    }

    public override void VisitShaderFile(ShaderFile shaderFile)
    {
        var rootClasses = shaderFile.RootDeclarations.OfType<ShaderClass>().ToList();
        if (rootClasses.Count > 0)
        {
            shaderFile.RootDeclarations.RemoveAll(x => x is ShaderClass);
            
            // Make sure all top-level objects without namespace are wrapped inside a namespace
            shaderFile.Namespaces.Add(new ShaderNamespace(default)
            {
                Namespace = new(DefaultNameSpace, default),
                NamespacePath = DefaultNameSpace.Split('.').Select(x => new Identifier(x, default)).ToList(),
                Declarations = rootClasses.ToList<ShaderDeclaration>(),
            });
        }

        base.VisitShaderFile(shaderFile);
    }

    public override void VisitShaderNamespace(ShaderNamespace shaderNamespace)
    {
        Write("namespace ").Write(string.Join(".", shaderNamespace.NamespacePath)).WriteLine();
        OpenBrace();

        var declarations = shaderNamespace.Declarations;

        // If multiple ShaderClass, we get only the last one
        // (otherwise our unit tests are generating too many collisions -- we could revisit that decision later if we allow more than one shader per file in production)
        var lastShaderClass = declarations.OfType<ShaderClass>().LastOrDefault();
        declarations = declarations.Where(x => x is not ShaderClass || x == lastShaderClass).ToList();
        
        foreach (var node in declarations)
        {
            VisitNode(node);
        }

        CloseBrace();
    }

    public override void VisitAssign(Assign assign)
    {
        if (assign.Variables.Count == 1
            && assign.Variables[0].Value is not null
            && TryParameters(assign.Variables[0].Variable, out var typeTarget, out var typeMember, out var extraPath))
        {
            Write("context.SetParam(").Write(typeTarget).Write(".").Write(typeMember.ToString()).Write(", ");
            VisitNode(assign.Variables[0].Value);
            Write(")");
            if (extraPath != null)
                Write(".").Write(extraPath);
        }
        else
        {
            base.VisitAssign(assign);
        }
    }
    
    public override void VisitAccessorChainExpression(AccessorChainExpression accessorChainExpression)
    {
        if (TryParameters(accessorChainExpression, out var typeTarget, out var typeMember, out var extraPath))
        {
            var key = typeTarget + "." + typeMember;
            Write("context.GetParam(").Write(typeTarget).Write(".").Write(typeMember.ToString()).Write(")");
            if (extraPath != null)
                Write(".").Write(extraPath);
        }
        else
        {
            base.VisitAccessorChainExpression(accessorChainExpression);
        }
    }

    private bool TryParameters(Expression expression, out string type, out string member, out string? extraPath)
    {
        type = null;
        member = null;
        extraPath = null;
        var accessorChainExpression = expression as AccessorChainExpression;
        if (accessorChainExpression == null || accessorChainExpression.Accessors[0] is not IdentifierBase accessMember)
            return false;

        var name = accessorChainExpression.Source.ToString();

        bool foundDeclaredParameters = false;
        if (IsParameterDeclaredInContext(name))
        {
            type = name;
            member = accessMember.ToString();
            extraPath = accessorChainExpression.Accessors.Count > 1 ? (string.Join(".", accessorChainExpression.Accessors[1..])) : null;
            foundDeclaredParameters = true;
        }

        return foundDeclaredParameters;
    }


    private void ExtractGenericParameters(Expression mixinStatementValue, out Expression mixinName, out ShaderExpressionList? genericParameters)
    {
        // Pattern like A.B<Param1, Param2>
        if (mixinStatementValue is AccessorChainExpression accessorChainExpression && accessorChainExpression.Accessors.Count > 0 && accessorChainExpression.Accessors[^1] is GenericIdentifier genericIdentifier1)
        {
            // Recreate an access chain expression without the generics at the end
            mixinName = new AccessorChainExpression(accessorChainExpression.Source, accessorChainExpression.Info) { Accessors = [..accessorChainExpression.Accessors[..^1], genericIdentifier1.Name] };
            genericParameters = genericIdentifier1.Generics;
        }
        // Pattern like A<Param1, Param2>
        else if (mixinStatementValue is GenericIdentifier genericIdentifier2)
        {
            mixinName = genericIdentifier2.Name;
            genericParameters = genericIdentifier2.Generics;
        }
        else
        {
            mixinName = mixinStatementValue;
            genericParameters = null;
        }
    }

    private void WriteGenericParameters(ShaderExpressionList? genericParameters)
    {
        if (genericParameters != null)
        {
            foreach (var genericParameter in genericParameters)
            {
                Write(", ");
                VisitNode(genericParameter);
            }
        }
    }

    public override void VisitVectorLiteral(VectorLiteral vectorLiteral)
    {
        Write("new ");
        VisitNode(vectorLiteral.TypeName);
        Write("(");
        for (var index = 0; index < vectorLiteral.Values.Count; index++)
        {
            if (index > 0)
                Write(", ");
            VisitNode(vectorLiteral.Values[index]);
        }

        Write(")");
    }

    public override void VisitTypeName(TypeName typeName)
    {
        if (VectorType.Types.TryGetValue(typeName.Name, out var v) && v is { BaseType.Type: Scalar.Float })
        {
            if (isProcessingColor)
                Write($"Color{v.Size}");
            else
                Write($"Vector{v.Size}");
        }
        else if (VectorType.Types.TryGetValue(typeName.Name, out var v2) && v2 is { BaseType.Type: Scalar.Int or Scalar.UInt })
        {
            Write($"Int{v.Size}");
        }
        else if (MatrixType.Types.TryGetValue(typeName.Name, out var m) && m is { Columns: 4, Rows: 4, BaseType.Type: Scalar.Float })
        {
            Write("Matrix");
        }
        else if (typeName.Type is BufferType or StructuredBufferType)
        {
            Write("Buffer");
        }
        else if (typeName.Type is TextureType)
        {
            Write("Texture");
        }
        else if (typeName.Type is SamplerType)
        {
            Write("SamplerState");
        }
        else
        {
            base.VisitTypeName(typeName);
        }
    }

    public override void VisitMixin(Mixin mixinStatement)
    {
        switch (mixinStatement.Kind)
        {
            case Specification.MixinKindSDFX.Default:
            {
                ExtractGenericParameters(mixinStatement.Value, out var mixinName, out var genericParameters);

                WriteLinkLine(mixinStatement);
                Write("context.Mixin(mixin, ");
                WriteMixinName(mixinName);
                WriteGenericParameters(genericParameters);
                WriteLine(");");
                break;
            }
            case Specification.MixinKindSDFX.Child:
            {
                // mixin child can come in 2 flavour:
                // 1) mixin child MyEffect
                //    => equivalent to 2) with "mixin child MyEffect = MyEffect"
                // 2) mixin child MyGenericEffectName = MyEffect
                ExtractGenericParameters(mixinStatement.Value, out var mixinName, out var genericParameters);
                var childName = mixinStatement.Target ?? (Identifier)mixinStatement.Value;
                {
                    WriteLinkLine(mixinStatement);
                    Write("if (context.ChildEffectName == ");
                    WriteMixinName(childName);
                    WriteLine(")");
                    OpenBrace();

                    WriteLinkLine(mixinStatement);
                    Write("context.Mixin(mixin, ");
                    WriteMixinName(mixinName);
                    WriteGenericParameters(genericParameters);
                    WriteLine(");");
                    WriteLine("return;");

                    CloseBrace();
                }
                break;
            }
            case Specification.MixinKindSDFX.Remove:
            {
                ExtractGenericParameters(mixinStatement.Value, out var mixinName, out var genericParameters);

                WriteLinkLine(mixinStatement);
                Write("context.RemoveMixin(mixin, ");
                WriteMixinName(mixinName);
                WriteGenericParameters(genericParameters);
                WriteLine(");");
                break;
            }
            case Specification.MixinKindSDFX.Macro:
            {
                WriteLinkLine(mixinStatement);
                Expression macroName;
                Expression macroValue;

                if (mixinStatement.Target != null)
                {
                    macroName = mixinStatement.Target;
                    if (macroName is Identifier id)
                        macroName = new StringLiteral(id.Name, id.Info);
                    macroValue = mixinStatement.Value;
                }
                else
                {
                    var variableReference = mixinStatement.Value as AccessorChainExpression;
                    if (variableReference == null || !(variableReference.Source is Identifier id) || !IsParameterDeclaredInContext(id.Name))
                    {
                        logging.Add(("Invalid syntax. Expecting: mixin macro Parameters.NameOfProperty or mixin macro nameOfProperty = value", mixinStatement.Info));
                        macroName = new StringLiteral("#INVALID_MACRO_NAME", default);
                        macroValue = mixinStatement.Value;
                    }
                    else
                    {
                        macroName = new StringLiteral(((Identifier)variableReference.Accessors[0]).Name, variableReference.Accessors[0].Info);
                        macroValue = mixinStatement.Value;
                    }
                }

                Write("mixin.AddMacro(");
                VisitNode(macroName);
                Write(", ");
                VisitNode(macroValue);
                WriteLine(");");
                break;
            }
            case Specification.MixinKindSDFX.ComposeSet:
            case Specification.MixinKindSDFX.ComposeAdd:
            {
                if (mixinStatement.Target == null)
                {
                    logging.Add(("Expecting assign expression for composition", mixinStatement.Value.Info));
                    return;
                }

                var addCompositionFunction = "PushComposition";

                // If it's a +=, let's create or complete a ShaderArraySource
                if (mixinStatement.Kind == Specification.MixinKindSDFX.ComposeAdd)
                {
                    addCompositionFunction = "PushCompositionArray";
                }

                ExtractGenericParameters(mixinStatement.Value, out var mixinName, out var genericParameters);

                OpenBrace();
                WriteLinkLine(mixinStatement);
                Write("var __mixinToCompose__ = ");
                WriteMixinName(mixinName);
                WriteLine(";");
                WriteLine("var __subMixin = new ShaderMixinSource();");

                WriteLinkLine(mixinStatement);
                Write("context.").Write(addCompositionFunction).Write("(mixin, ");
                WriteStringOrExpression(mixinStatement.Target);
                WriteLine(", __subMixin);");

                WriteLinkLine(mixinStatement);
                Write("context.Mixin(__subMixin, __mixinToCompose__");
                WriteGenericParameters(genericParameters);
                WriteLine(");");

                WriteLinkLine(mixinStatement);
                WriteLine("context.PopComposition();");
                CloseBrace();
                break;
            }
        }
    }

    private void WriteMixinName(Expression mixinName)
    {
        WriteStringOrExpression(mixinName);
    }

    private void WriteStringOrExpression(Expression expr)
    {
        // Output between "" only if the mixin name is only a variable
        if (expr is Identifier)
            Write("\"");
        VisitNode(expr);
        if (expr is Identifier)
            Write("\"");
    }

    public override void VisitUsingParams(UsingParams usingParametersStatement)
    {
        if (contextStack.Count == 0)
        {
            logging.Add(("Unexpected 'using params' outside of shader block declaration", usingParametersStatement.Info));
            return;
        }

        var currentContext = contextStack.Peek();
        HashSet<string> usings = currentContext.DeclaredParameters;

        // If simple name, it is a simple reference of a ParameterBlock
        if (usingParametersStatement.ParamsName is Identifier type)
        {
            var typeName = type.ToString();
            if (usings.Contains(typeName))
            {
                logging.Add(("Unexpected declaration of using params. This variable is already declared in this scope", usingParametersStatement.Info));
                return;
            }

            usings.Add(typeName);
        }
    }

    public override void VisitShaderClass(ShaderClass shaderClass)
    {
        table.Push();
        
        // Process generic symbols (might be used in type arrays)
        if (shaderClass.Generics != null)
        {
            for (int i = 0; i < shaderClass.Generics.Parameters.Count; i++)
                shaderClass.ProcessGenericSymbol(table, table.Context, i, shaderClass.Generics.Parameters[i]);
        }

        Write(shaderClass.Internal ? "internal " : "public ");
        Write("static partial class ");
        Write(shaderClass.Name);
        WriteLine("Keys");
        {
            OpenBrace();
            foreach (var decl in shaderClass.Elements)
            {
                if (decl is ShaderMember or ShaderStruct or ShaderSamplerState)
                {
                    VisitNode(decl);
                }
                else if (decl is ShaderBuffer b)
                {
                    foreach (var subDecl in b.Members)
                    {
                        VisitNode(subDecl);
                    }
                }
            }
            CloseBrace();
        }

        table.Pop();
    }

    public override void VisitEffectParameters(EffectParameters effectParameters)
    {
        WriteLine("[DataContract]");
        WriteLinkLine(effectParameters);
        Write("public partial class");
        Write(" ");
        Write(effectParameters.Name);
        WriteSpace();
        WriteLine(": ShaderMixinParameters");
        {
            OpenBrace();

            foreach (var parameter in effectParameters.Parameters)
            {
                WriteLinkLine(parameter);
                WriteVariableAsParameterKey(true, parameter.Type, parameter.Identifier, parameter.DefaultValue, []);
                if (parameter.DefaultValue != null)
                    throw new NotImplementedException();
            }

            CloseBrace(false).WriteLine();
        }
    }
    
    internal bool IsParameterKey(ShaderElement element)
    {
        if (element is ShaderMember member)
        {
            if (member.IsCompose
                || member.TypeModifier == TypeModifier.Const
                || member.StreamKind != StreamKind.None)
                return false;
        }
        // TODO:
        // Don't generate a parameter key for variable stored storage qualifier: extern, const, compose, stream
        //if (variable.Qualifiers.Contains(HlslStorageQualifier.Extern) ||
        //    variable.Qualifiers.Contains(StorageQualifier.Const) ||
        //    variable.Qualifiers.Contains(StrideStorageQualifier.Compose) ||
        //    variable.Qualifiers.Contains(StrideStorageQualifier.PatchStream) ||
        //    variable.Qualifiers.Contains(StorageQualifier.GroupShared) ||
        //    variable.Qualifiers.Contains(StrideStorageQualifier.Stream))
        //    return false;
        //
        //// Don't generate a parameter key for [Link] or [RenameLink]
        //if (variable.Attributes.OfType<AttributeDeclaration>().Any(x => x.Name == "RenameLink" || x.Name == "Link"))
        //    return false;

        return true;
    }

    private class ShaderBlockContext
    {
        public readonly HashSet<string> DeclaredParameters = new HashSet<string>();
    }

    /// <summary>
    /// Internal visitor to precalculate all available Parameters in the context
    /// </summary>
    private sealed class ShaderBlockVisitor : NodeWalker
    {
        private ShaderBlockContext currentContext;

        private readonly EffectCodeWriter parent;

        public ShaderBlockVisitor(EffectCodeWriter parent)
        {
            this.parent = parent;
        }

        public bool HasMixin { get; private set; }

        public bool HasShaderClassType { get; private set; }

        public override void VisitEffectParameters(EffectParameters paramsBlock)
        {
            HasMixin = true;
        }

        public override void VisitShaderEffect(ShaderEffect shaderEffect)
        {
            HasMixin = true;
        }
        
        public override void VisitShaderClass(ShaderClass shaderClassType)
        {
            // Check if there are any parameter keys in ShaderClassType and ConstantBuffer
            CheckParameterKeys(shaderClassType.Elements.OfType<ShaderMember>());
            CheckParameterKeys(shaderClassType.Elements.OfType<ShaderBuffer>().SelectMany(cbuffer => cbuffer.Members));
        }

        private void CheckParameterKeys(IEnumerable<ShaderMember> variables)
        {
            foreach (var variable in variables)
            {
                if (!HasShaderClassType)
                {
                    if (parent.IsParameterKey(variable))
                    {
                        HasShaderClassType = true;
                    }
                }
            }
        }
    }
}