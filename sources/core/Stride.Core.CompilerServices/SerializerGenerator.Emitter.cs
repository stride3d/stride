using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Stride.Core.CompilerServices
{
    public partial class SerializerGenerator
    {
        private const string ParentSerializerFieldName = "parentSerializer";

        private static readonly SymbolDisplayFormat NamespaceWithTypeNameWithoutGenerics = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces);
        private static readonly SymbolDisplayFormat NamespaceWithTypeNameWithGenerics = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable);

        internal static void EmitCode(GeneratorExecutionContext context, SerializerSpec serializerSpec)
        {
            EmitDataContractSerializers(context, serializerSpec);
        }

        private static void EmitDataContractSerializers(GeneratorExecutionContext context, SerializerSpec serializerSpec)
        {
            foreach (var typeSpec in serializerSpec.DataContractTypes)
            {
                var serializerName = typeSpec.Type.ToDisplayString(NamespaceWithTypeNameWithoutGenerics).Replace(".", "_") + "Serializer";
                var typeName = typeSpec.Type.ToDisplayString();
                var builder = new StringBuilder();

                builder.AppendLine("// <auto-generated/>");
                builder.AppendLine("using Stride.Core.Serialization;");
                builder.AppendLine();
                builder.AppendLine("namespace Stride.Core.DataSerializers.V2;");
                builder.AppendLine();

                builder.Append("internal sealed class ").Append(serializerName);

                if (typeSpec.Type.IsGenericType)
                {
                    builder.Append("<");
                    var genericParameters = typeSpec.Type.TypeParameters;
                    for (int i = 0; i < genericParameters.Length; i++)
                    {
                        if (i > 0) builder.Append(", ");
                        builder.Append(genericParameters[i].Name);
                    }
                    builder.Append(">");
                }

                builder.Append(" : ");

                if (typeSpec.Type.IsValueType || typeSpec.Type.IsAbstract)
                {
                    builder.Append("DataSerializer");
                }
                else
                {
                    builder.Append("ClassDataSerializer");
                }

                builder.Append("<").Append(typeName).Append(">");
                builder.AppendLine();

                // emit generic type constraints
                EmitDataContractSerializerGenericConstraints(typeSpec, builder);

                builder.AppendLine("{");

                // Emit private fields - serializers, one for each type
                var serializers = GetDataContractSerializerFieldList(typeSpec);
                foreach (var (fieldName, serializerType) in serializers)
                {
                    EmitDataContractSerializerField(builder, fieldName, serializerType);
                }
                // And one for parent, if present
                if (typeSpec.BaseType != null)
                {
                    EmitDataContractSerializerField(builder, ParentSerializerFieldName, typeSpec.BaseType);
                }

                builder.AppendLine();
                builder.AppendLine("  public override void Initialize(SerializerSelector serializerSelector)");
                builder.AppendLine("  {");
                // Create a member serializer for each member type
                foreach (var (fieldName, serializerType) in serializers)
                {
                    builder.Append("    this.").Append(fieldName).Append(" = MemberSerializer<").Append(serializerType.ToDisplayString()).Append(">.Create(serializerSelector);").AppendLine();
                }
                // Get a serializer for the parent type
                if (typeSpec.BaseType != null)
                {
                    builder.Append("    this.").Append(ParentSerializerFieldName).Append(" = serializerSelector.GetSerializer<").Append(typeSpec.BaseType.ToDisplayString()).Append(">();").AppendLine();
                }
                builder.AppendLine("  }");

                builder.AppendLine();
                builder.AppendLine("  public override void Serialize(");
                builder.Append("    ref ").Append(typeName).Append(" obj,").AppendLine();
                builder.Append("    ArchiveMode mode,").AppendLine();
                builder.Append("    SerializationStream stream)").AppendLine();
                builder.AppendLine("  {");
                // TODO: Serialize(...)
                builder.AppendLine("  }");

                builder.AppendLine("}");

                // serializerFileName is serializerName with generic args arity
                var serializerFileName = typeSpec.Type.ToDisplayString(NamespaceWithTypeNameWithoutGenerics).Replace(".", "_") + typeSpec.Type.TypeArguments.Length + "Serializer";
                context.AddSource(serializerFileName, builder.ToString());
            }
        }

        private static void EmitDataContractSerializerGenericConstraints(SerializerTypeSpec typeSpec, StringBuilder builder)
        {
            if (typeSpec.Type.TypeParameters.Length > 0)
            {
                foreach (var typeParam in typeSpec.Type.TypeParameters)
                {
                    var constraintBuilder = new StringBuilder();
                    if (typeParam.HasValueTypeConstraint) constraintBuilder.Append("struct");
                    if (typeParam.HasReferenceTypeConstraint) constraintBuilder.Append("class");
                    if (typeParam.HasConstructorConstraint)
                    {
                        if (constraintBuilder.Length > 0)
                        {
                            constraintBuilder.Append(", ");
                        }
                        constraintBuilder.Append("new()");
                    }
                    foreach (var constraintType in typeParam.ConstraintTypes)
                    {
                        if (constraintBuilder.Length > 0)
                        {
                            constraintBuilder.Append(", ");
                        }
                        constraintBuilder.Append(constraintType.Name);
                    }

                    if (constraintBuilder.Length > 0)
                    {
                        builder.Append("  where ").Append(typeParam.Name).Append(" : ").Append(constraintBuilder.ToString()).AppendLine();
                    }
                }
            }
        }

        private static void EmitDataContractSerializerField(StringBuilder builder, string fieldName, ITypeSymbol serializerType)
        {
            builder.Append("  private DataSerializer<").Append(serializerType.ToDisplayString()).Append("> ").Append(fieldName).Append(";").AppendLine();
        }

        private static List<(string, ITypeSymbol)> GetDataContractSerializerFieldList(SerializerTypeSpec typeSpec)
        {
            var serializers = new List<(string, ITypeSymbol)>();
            foreach (var distinctMemberType in typeSpec.Members.Select(static member => member.Type).Distinct(SymbolEqualityComparer.Default).Cast<ITypeSymbol>())
            {
                serializers.Add((
                    distinctMemberType.ToDisplayString(NamespaceWithTypeNameWithGenerics)
                        .Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(", ", "_").Replace("[]", "Array")
                        + "__Serializer",
                    distinctMemberType));
            }

            return serializers;
        }
    }
}
