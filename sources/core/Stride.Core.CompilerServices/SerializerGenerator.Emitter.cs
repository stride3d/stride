using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Stride.Core.CompilerServices
{
    public partial class SerializerGenerator
    {
        private static readonly SymbolDisplayFormat NamespaceWithTypeNameWithoutGenerics = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces);
        private static readonly SymbolDisplayFormat NamespaceWithTypeNameWithGenerics = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable);

        internal static void EmitCode(GeneratorExecutionContext context, SerializerSpec serializerSpec)
        {
            EmitDataContractSerializers(context, serializerSpec);
        }

        private static void EmitDataContractSerializers(GeneratorExecutionContext context, SerializerSpec serializerSpec)
        {
            foreach (var typeSpec in serializerSpec.DataContractTypes)
            {
                var serializerName = typeSpec.Type.ToDisplayString(NamespaceWithTypeNameWithoutGenerics).Replace(".", "_") + "Serializer";
                var typeName = typeSpec.Type.ToDisplayString();
                var builder = new StringBuilder();

                builder.AppendLine("// <auto-generated/>");
                builder.AppendLine("using Stride.Core.Serialization;");
                builder.AppendLine();
                builder.AppendLine("namespace Stride.Core.DataSerializers.V2;");
                builder.AppendLine();

                builder.Append("internal sealed class ").Append(serializerName);

                if (typeSpec.Type.IsGenericType)
                {
                    builder.Append("<");
                    var genericParameters = typeSpec.Type.TypeArguments;
                    for (int i = 0; i < genericParameters.Length; i++)
                    {
                        if (i > 0) builder.Append(", ");
                        builder.Append(genericParameters[i].Name);
                    }
                    builder.Append(">");
                }

                builder.Append(" : ");

                if (typeSpec.Type.IsValueType || typeSpec.Type.IsAbstract)
                {
                    builder.Append("DataSerializer");
                }
                else
                {
                    builder.Append("ClassDataSerializer");
                }

                builder.Append("<").Append(typeName).Append(">");
                builder.AppendLine();

                // emit generic type constraints
                if (typeSpec.Type.TypeParameters.Length > 0)
                {
                    foreach (var typeParam in typeSpec.Type.TypeParameters)
                    {
                        var constraintBuilder = new StringBuilder();
                        if (typeParam.HasValueTypeConstraint) constraintBuilder.Append("struct");
                        if (typeParam.HasReferenceTypeConstraint) constraintBuilder.Append("class");
                        if (typeParam.HasConstructorConstraint)
                        {
                            if (constraintBuilder.Length > 0)
                            {
                                constraintBuilder.Append(", ");
                            }
                            constraintBuilder.Append("new()");
                        }
                        foreach (var constraintType in typeParam.ConstraintTypes)
                        {
                            if (constraintBuilder.Length > 0)
                            {
                                constraintBuilder.Append(", ");
                            }
                            constraintBuilder.Append(constraintType.Name);
                        }

                        if (constraintBuilder.Length > 0)
                        {
                            builder.Append("  where ").Append(typeParam.Name).Append(" : ").Append(constraintBuilder.ToString()).AppendLine();
                        }
                    }
                }

                builder.AppendLine("{");
                var serializers = GetSerializerFieldList(typeSpec);

                foreach (var kvp in serializers)
                {
                    var fieldName = kvp.Key;
                    var serializerType = kvp.Value;
                    builder.Append("  private DataSerializer<").Append(serializerType.ToDisplayString()).Append("> ").Append(fieldName).Append(";").AppendLine();
                }

                builder.AppendLine();
                builder.AppendLine("  public override void Initialize(SerializerSelector serializerSelector)");
                builder.AppendLine("  {");
                // TODO: Initialize(...)
                builder.AppendLine("  }");

                builder.AppendLine();
                builder.AppendLine("  public override void Serialize(");
                builder.Append("    ref ").Append(typeName).Append(" obj,").AppendLine();
                builder.Append("    ArchiveMode mode,").AppendLine();
                builder.Append("    SerializationStream stream)").AppendLine();
                builder.AppendLine("  {");
                // TODO: Serialize(...)
                builder.AppendLine("  }");

                builder.AppendLine("}");

                // serializerFileName is serializerName with generic args arity
                var serializerFileName = typeSpec.Type.ToDisplayString(NamespaceWithTypeNameWithoutGenerics).Replace(".", "_") + typeSpec.Type.TypeArguments.Length + "Serializer";
                context.AddSource(serializerFileName, builder.ToString());
            }
        }

        private static Dictionary<string, ITypeSymbol> GetSerializerFieldList(SerializerTypeSpec typeSpec)
        {
            var serializers = new Dictionary<string, ITypeSymbol>();
            foreach (var distinctMemberType in typeSpec.Members.Select(static member => member.Type).Distinct(SymbolEqualityComparer.Default).Cast<ITypeSymbol>())
            {
                serializers.Add(
                    distinctMemberType.ToDisplayString(NamespaceWithTypeNameWithGenerics)
                        .Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(", ", "_").Replace("[]", "Array")
                        + "__Serializer",
                    distinctMemberType);
            }
            if (!typeSpec.Type.BaseType.Equals(systemObjectSymbol, SymbolEqualityComparer.Default))
            {
                serializers.Add("parentSerializer", typeSpec.Type.BaseType);
            }

            return serializers;
        }
    }
}
