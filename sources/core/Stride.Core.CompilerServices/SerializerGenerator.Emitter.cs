using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Stride.Core.CompilerServices
{
    public partial class SerializerGenerator
    {
        private const string ParentSerializerFieldName = "parentSerializer";

        private static readonly SymbolDisplayFormat NamespaceWithTypeNameWithoutGenerics = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces);
        private static readonly SymbolDisplayFormat NamespaceWithTypeNameWithGenerics = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable);

        internal static void EmitCode(GeneratorExecutionContext context, SerializerSpec serializerSpec)
        {
            EmitDataContractSerializers(context, serializerSpec);
        }

        private static void EmitDataContractSerializers(GeneratorExecutionContext context, SerializerSpec serializerSpec)
        {
            foreach (var typeSpec in serializerSpec.DataContractTypes)
            {
                try
                {
                    var serializerName = typeSpec.Type.ToDisplayString(NamespaceWithTypeNameWithoutGenerics).Replace(".", "_") + "Serializer";
                    var typeName = typeSpec.Type.ToDisplayString();
                    var builder = new StringBuilder();

                    builder.AppendLine("// <auto-generated/>");
                    builder.AppendLine("using System.Runtime.CompilerServices;");
                    builder.AppendLine("using Stride.Core.Serialization;");
                    builder.AppendLine();
                    builder.AppendLine("namespace Stride.Core.DataSerializers.V2;");
                    builder.AppendLine();

                    // emit class header
                    {
                        builder.Append("internal sealed class ").Append(serializerName);

                        if (typeSpec.Type.IsGenericType)
                        {
                            builder.Append("<");
                            var genericParameters = typeSpec.Type.TypeParameters;
                            for (int i = 0; i < genericParameters.Length; i++)
                            {
                                if (i > 0) builder.Append(", ");
                                builder.Append(genericParameters[i].Name);
                            }
                            builder.Append(">");
                        }

                        builder.Append(" : ");

                        if (typeSpec.Type.IsValueType || typeSpec.Type.IsAbstract)
                        {
                            builder.Append("DataSerializer");
                        }
                        else
                        {
                            builder.Append("ClassDataSerializer");
                        }

                        builder.Append("<").Append(typeName).Append(">");
                        builder.AppendLine();

                        // emit generic type constraints
                        EmitDataContractSerializerGenericConstraints(typeSpec, builder);
                    }
                    builder.AppendLine("{");

                    // Emit private fields - serializers, one for each type
                    var serializers = GetDataContractSerializerFieldList(typeSpec);
                    foreach (var (fieldName, serializerType) in serializers)
                    {
                        EmitDataContractSerializerField(builder, fieldName, serializerType);
                    }
                    // And one for parent, if present
                    if (typeSpec.BaseType != null)
                    {
                        EmitDataContractSerializerField(builder, ParentSerializerFieldName, typeSpec.BaseType);
                    }

                    builder.AppendLine();
                    
                    builder.AppendLine("    public override void Initialize(SerializerSelector serializerSelector)");
                    builder.AppendLine("    {");
                    // Create a member serializer for each member type
                    foreach (var (fieldName, serializerType) in serializers)
                    {
                        builder.Append("        this.").Append(fieldName).Append(" = MemberSerializer<").Append(serializerType.ToDisplayString()).Append(">.Create(serializerSelector);").AppendLine();
                    }
                    // Get a serializer for the parent type
                    if (typeSpec.BaseType != null)
                    {
                        builder.Append("        this.").Append(ParentSerializerFieldName).Append(" = serializerSelector.GetSerializer<").Append(typeSpec.BaseType.ToDisplayString()).Append(">();").AppendLine();
                    }
                    builder.AppendLine("    }");

                    builder.AppendLine();

                    builder.AppendLine("    public override void Serialize(");
                    builder.Append("        ref ").Append(typeName).Append(" obj,").AppendLine();
                    builder.Append("        ArchiveMode mode,").AppendLine();
                    builder.Append("        SerializationStream stream)").AppendLine();
                    builder.AppendLine("    {");

                    // emit serialization of the parent
                    if (typeSpec.BaseType != null)
                    {
                        // we need to have a ref variable of the base type for it to get the correct overload of the parentSerializer's Serialize method
                        // you cannot cast a ref variable in C# (this is to prevent invalid assignments)
                        // so we're using Unsafe.As to perform this cast
                        builder.Append("        ref var local_base = ref Unsafe.As<").Append(typeSpec.Type.ToDisplayString()).Append(", ").Append(typeSpec.BaseType.ToDisplayString()).Append(">(ref obj);").AppendLine();
                        builder.Append("        this.").Append(ParentSerializerFieldName).Append(".Serialize(ref local_base").Append(", mode, stream);").AppendLine();
                    }

                    if (typeSpec.Members.Count > 0)
                    {
                        builder.AppendLine("        if (mode == ArchiveMode.Serialize)");
                        builder.AppendLine("        {");

                        foreach (var member in typeSpec.Members)
                        {
                            EmitDataContractSerializerMemberSerialization(builder, serializers, member);
                        }

                        builder.AppendLine("        }");
                        builder.AppendLine("        else");
                        builder.AppendLine("        {");

                        foreach (var member in typeSpec.Members)
                        {
                            EmitDataContractSerializerMemberSerialization(builder, serializers, member);
                            if (member.AccessMode.HasFlag(MemberAccessMode.WithAssignment))
                            {
                                builder.Append("            obj.").Append(member.Name).Append(" = local").Append(member.Name).Append(";").AppendLine();
                            }
                        }

                        builder.AppendLine("        }");
                    }
                    builder.AppendLine("    }");

                    builder.AppendLine("}");

                    // serializerFileName is serializerName with generic args arity
                    var serializerFileName = typeSpec.Type.ToDisplayString(NamespaceWithTypeNameWithoutGenerics).Replace(".", "_") + typeSpec.Type.TypeArguments.Length + "Serializer";
                    context.AddSource(serializerFileName, builder.ToString());
                }
                catch (Exception ex)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        CompilerServicesExceptionDuringDataContractGeneration,
                        typeSpec.Type.Locations.FirstOrDefault(),
                        typeSpec.Type.ToDisplayString(SimpleClassNameWithNestedInfo),
                        ex.GetType().Name,
                        ex.ToString()));
                }
            }
        }

        private static void EmitDataContractSerializerMemberSerialization(StringBuilder builder, List<(string fieldName, ITypeSymbol type)> serializers, SerializerMemberSpec member)
        {
            var serializerField = serializers.First(p => p.type.Equals(member.Type, SymbolEqualityComparer.Default)).fieldName;
            if (member.AccessMode.HasFlag(MemberAccessMode.ByRef))
            {
                builder.Append("            this.").Append(serializerField).Append(".Serialize(ref obj.").Append(member.Name).Append(", mode, stream);").AppendLine();
            }
            else if (member.AccessMode.HasFlag(MemberAccessMode.ByLocalRef))
            {
                builder.Append("            var local").Append(member.Name).Append(" = obj.").Append(member.Name).Append(";").AppendLine();
                builder.Append("            this.").Append(serializerField).Append(".Serialize(ref local").Append(member.Name).Append(", mode, stream);").AppendLine();
            }
        }

        private static void EmitDataContractSerializerGenericConstraints(SerializerTypeSpec typeSpec, StringBuilder builder)
        {
            if (typeSpec.Type.TypeParameters.Length > 0)
            {
                foreach (var typeParam in typeSpec.Type.TypeParameters)
                {
                    var constraintBuilder = new StringBuilder();
                    if (typeParam.HasValueTypeConstraint) constraintBuilder.Append("struct");
                    if (typeParam.HasReferenceTypeConstraint) constraintBuilder.Append("class");
                    if (typeParam.HasConstructorConstraint)
                    {
                        if (constraintBuilder.Length > 0)
                        {
                            constraintBuilder.Append(", ");
                        }
                        constraintBuilder.Append("new()");
                    }
                    foreach (var constraintType in typeParam.ConstraintTypes)
                    {
                        if (constraintBuilder.Length > 0)
                        {
                            constraintBuilder.Append(", ");
                        }
                        constraintBuilder.Append(constraintType.Name);
                    }

                    if (constraintBuilder.Length > 0)
                    {
                        builder.Append("  where ").Append(typeParam.Name).Append(" : ").Append(constraintBuilder.ToString()).AppendLine();
                    }
                }
            }
        }

        private static void EmitDataContractSerializerField(StringBuilder builder, string fieldName, ITypeSymbol serializerType)
        {
            builder.Append("    private DataSerializer<").Append(serializerType.ToDisplayString()).Append("> ").Append(fieldName).Append(";").AppendLine();
        }

        private static List<(string fieldName, ITypeSymbol type)> GetDataContractSerializerFieldList(SerializerTypeSpec typeSpec)
        {
            var serializers = new List<(string, ITypeSymbol)>();
            foreach (var distinctMemberType in typeSpec.Members.Select(static member => member.Type).Distinct(SymbolEqualityComparer.Default).Cast<ITypeSymbol>())
            {
                serializers.Add((
                    distinctMemberType.ToDisplayString(NamespaceWithTypeNameWithGenerics)
                        .Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(", ", "_").Replace("[]", "Array")
                        + "__Serializer",
                    distinctMemberType));
            }

            return serializers;
        }
    }
}
