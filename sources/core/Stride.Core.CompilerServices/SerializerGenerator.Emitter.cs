using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Stride.Core.CompilerServices.Extensions;
using Stride.Core.CompilerServices.Models;
using static Stride.Core.CompilerServices.Diagnostics;

namespace Stride.Core.CompilerServices
{
    public partial class SerializerGenerator
    {
        private const string ParentSerializerFieldName = "parentSerializer";
        private const string TargetNameSpace = "Stride.Core.DataSerializers.V2";

        private static readonly SymbolDisplayFormat NamespaceWithTypeNameWithoutGenerics = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces);
        private static readonly SymbolDisplayFormat NamespaceWithTypeNameWithGenerics = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable);

        internal static void EmitCode(GeneratorExecutionContext context, SerializerSpec serializerSpec)
        {
            EmitDataContractSerializers(context, serializerSpec);
            EmitSerializerFactory(context, serializerSpec);
        }

        private static void EmitSerializerFactory(GeneratorExecutionContext context, SerializerSpec serializerSpec)
        {
            var serializerFactoryName = serializerSpec.Assembly.Name.Replace(".", "_") + "SerializerFactory";
            var builder = new StringBuilder();

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("using Stride.Core.Serialization;");
            builder.AppendLine();
            
            // TODO: uncomment later to start using V2 code instead of V1
            builder.Append("[assembly:AssemblySerializerFactoryAttribute(Type = typeof(")
                .Append(TargetNameSpace).Append(".").Append(serializerFactoryName).Append("))]").AppendLine().AppendLine();
            
            builder.AppendFormat("namespace {0};", TargetNameSpace).AppendLine();
            builder.AppendLine();

            foreach (var registration in serializerSpec.GlobalSerializerRegistrationsToEmit)
            {

                builder.Append("[DataSerializerGlobal(");
                
                if (registration.Value.SerializerType == null && !registration.Value.Generated)
                {
                    builder.Append("null, ");
                }
                else
                {
                    var serializerTypeString = registration.Value.SerializerType != null
                       ? GetTypeNameForTypeOf(registration.Value.SerializerType)
                       : TargetNameSpace + "." + MakeSerializerNameForTypeOf(registration.Value.DataType);
                    builder.Append("typeof(").Append(serializerTypeString).Append("), ");
                }

                if (registration.Value.DataType == null && !registration.Value.Generated)
                {
                    builder.Append("null, ");
                }
                else
                {
                    var dataTypeString = GetTypeNameForTypeOf(registration.Value.DataType);
                    if (dataTypeString == "T?<>") dataTypeString = "System.Nullable<>"; // HACK: I don't know where this could be configured to render properly
                    builder.Append("typeof(").Append(dataTypeString).Append("), ");
                }

                builder.Append("DataSerializerGenericMode.").Append(registration.Value.GenericMode.ToString()).Append(", ")
                    .Append("inherited: ").Append(registration.Value.Inherited.ToString().ToLower()).Append(", ")
                    .Append("complexSerializer: ").Append(registration.Value.Generated.ToString().ToLower()).Append(", ")
                    .Append("Profile = \"").Append(registration.Value.Profile).Append("\")]")
                    .AppendLine();
            }

            builder.Append("public static class ").Append(serializerFactoryName).AppendLine();
            builder.AppendLine("{");
            builder.AppendLine("}");

            context.AddSource(serializerFactoryName, builder.ToString());
        }

        private static string MakeSerializerNameForTypeOf(ITypeSymbol type)
        {
            var dataType = type as INamedTypeSymbol;
            var builder = new StringBuilder();
            builder.Append(GetDataContractSerializerName(dataType, includeArity: false));
            if (dataType.TypeParameters.Length > 0)
            {
                builder.Append("<");
                bool unbound = dataType.IsUnboundGenericType;
                for (int i = 0; i < dataType.TypeParameters.Length; i++)
                {
                    if (i != 0) builder.Append(",");
                    if (!unbound) builder.Append(dataType.TypeArguments[i].ToDisplayString());
                }
                builder.Append(">");
            }
            return builder.ToString();
        }

        private static string GetTypeNameForTypeOf(ITypeSymbol type)
        {
            if (type is INamedTypeSymbol namedType)
            {
                return namedType.IsUnboundGenericType
                    ? $"{namedType.ToDisplayString(NamespaceWithTypeNameWithoutGenerics)}<{"".PadLeft(namedType.TypeParameters.Length - 1, ',')}>"
                    : namedType.ToDisplayString(NamespaceWithTypeNameWithGenerics);
            }

            return type.ToDisplayString();
        }

        private static void EmitDataContractSerializers(GeneratorExecutionContext context, SerializerSpec serializerSpec)
        {
            foreach (var typeSpec in serializerSpec.DataContractTypes)
            {
                try
                {
                    var serializerName = GetDataContractSerializerName(typeSpec.Type, includeArity: false);
                    var typeName = typeSpec.Type.ToDisplayString();
                    var builder = new StringBuilder();

                    builder.AppendLine("// <auto-generated/>");
                    builder.AppendLine("using System.Runtime.CompilerServices;");
                    builder.AppendLine("using Stride.Core.Serialization;");
                    builder.AppendLine();
                    builder.AppendFormat("namespace {0};", TargetNameSpace).AppendLine();
                    builder.AppendLine();

                    // emit class header
                    {
                        // serializers for closed types can internal because they won't be accessed directly (only through registry)
                        // serializers for open types need to be public so that we can register their specializations in child assemblies
                        // i.e. assembly A defines S<T>, assembly B defines K : S<int>, assembly B needs to register SSerializer<int>
                        // because registry currently doesn't support open types (there's non-PRed code on that here https://github.com/manio143/stride/tree/dataAsset) 
                        var accessModifier = typeSpec.Type.IsGenericType && typeSpec.Type.DeclaredAccessibility == Accessibility.Public
                            ? "public"
                            : "internal";

                        builder.Append(accessModifier).Append(" sealed class ").Append(serializerName);

                        if (typeSpec.Type.IsGenericType)
                        {
                            builder.Append("<");
                            var genericParameters = typeSpec.Type.TypeParameters;
                            for (int i = 0; i < genericParameters.Length; i++)
                            {
                                if (i > 0) builder.Append(", ");
                                builder.Append(genericParameters[i].Name);
                            }
                            builder.Append(">");
                        }

                        builder.Append(" : ");

                        if (typeSpec.Type.IsValueType || typeSpec.Type.IsAbstract || typeSpec.HasInternalContructor)
                        {
                            builder.Append("DataSerializer");
                        }
                        else
                        {
                            builder.Append("ClassDataSerializer");
                        }

                        builder.Append("<").Append(typeName).Append(">");
                        builder.AppendLine();

                        // emit generic type constraints
                        EmitDataContractSerializerGenericConstraints(typeSpec, builder);
                    }
                    builder.AppendLine("{");

                    // Emit private fields - serializers, one for each type
                    var serializers = GetDataContractSerializerFieldList(typeSpec);
                    foreach (var (fieldName, serializerType) in serializers)
                    {
                        EmitDataContractSerializerField(builder, fieldName, serializerType);
                    }
                    // And one for parent, if present
                    if (typeSpec.BaseType != null)
                    {
                        EmitDataContractSerializerField(builder, ParentSerializerFieldName, typeSpec.BaseType);
                    }

                    builder.AppendLine();
                    
                    builder.AppendLine("    public override void Initialize(SerializerSelector serializerSelector)");
                    builder.AppendLine("    {");
                    // Create a member serializer for each member type
                    foreach (var (fieldName, serializerType) in serializers)
                    {
                        builder.Append("        this.").Append(fieldName).Append(" = MemberSerializer<").Append(serializerType.ToDisplayString()).Append(">.Create(serializerSelector);").AppendLine();
                    }
                    // Get a serializer for the parent type
                    if (typeSpec.BaseType != null)
                    {
                        builder.Append("        this.").Append(ParentSerializerFieldName).Append(" = serializerSelector.GetSerializer<").Append(typeSpec.BaseType.ToDisplayString()).Append(">();").AppendLine();
                    }
                    builder.AppendLine("    }");

                    builder.AppendLine();

                    builder.AppendLine("    public override void Serialize(");
                    builder.Append("        ref ").Append(typeName).Append(" obj,").AppendLine();
                    builder.Append("        ArchiveMode mode,").AppendLine();
                    builder.Append("        SerializationStream stream)").AppendLine();
                    builder.AppendLine("    {");

                    if (typeSpec.HasInternalContructor && !typeSpec.Type.IsAbstract)
                    {
                        builder.Append("        if (obj == null) obj = new ").Append(typeName).Append("();").AppendLine();
                    }

                    // emit serialization of the parent
                    if (typeSpec.BaseType != null)
                    {
                        // we need to have a ref variable of the base type for it to get the correct overload of the parentSerializer's Serialize method
                        // you cannot cast a ref variable in C# (this is to prevent invalid assignments)
                        // so we're using Unsafe.As to perform this cast
                        builder.Append("        ref var local_base = ref Unsafe.As<").Append(typeSpec.Type.ToDisplayString()).Append(", ").Append(typeSpec.BaseType.ToDisplayString()).Append(">(ref obj);").AppendLine();
                        builder.Append("        this.").Append(ParentSerializerFieldName).Append(".Serialize(ref local_base").Append(", mode, stream);").AppendLine();
                    }

                    if (typeSpec.Members.Count > 0)
                    {
                        builder.AppendLine("        if (mode == ArchiveMode.Serialize)");
                        builder.AppendLine("        {");

                        foreach (var member in typeSpec.Members)
                        {
                            EmitDataContractSerializerMemberSerialization(builder, serializers, member);
                        }

                        builder.AppendLine("        }");
                        builder.AppendLine("        else");
                        builder.AppendLine("        {");

                        foreach (var member in typeSpec.Members)
                        {
                            EmitDataContractSerializerMemberSerialization(builder, serializers, member);
                            if (member.AccessMode.HasFlag(MemberAccessMode.WithAssignment))
                            {
                                builder.Append("            obj.").Append(member.Name).Append(" = local").Append(member.Name).Append(";").AppendLine();
                            }
                        }

                        builder.AppendLine("        }");
                    }
                    builder.AppendLine("    }");

                    builder.AppendLine("}");

                    var serializerFileName = GetDataContractSerializerName(typeSpec.Type, includeArity: true);
                    context.AddSource(serializerFileName, builder.ToString());
                }
                catch (Exception ex)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        CompilerServicesExceptionDuringDataContractGeneration,
                        typeSpec.Type.Locations.FirstOrDefault(),
                        typeSpec.Type.ToStringSimpleClass(),
                        ex.GetType().Name,
                        ex.ToString()));
                }
            }
        }

        private static void EmitDataContractSerializerMemberSerialization(StringBuilder builder, List<(string fieldName, ITypeSymbol type)> serializers, SerializerMemberSpec member)
        {
            var serializerField = serializers.First(p => p.type.Equals(member.Type, SymbolEqualityComparer.Default)).fieldName;
            if (member.AccessMode.HasFlag(MemberAccessMode.ByRef))
            {
                builder.Append("            this.").Append(serializerField).Append(".Serialize(ref obj.").Append(member.Name).Append(", mode, stream);").AppendLine();
            }
            else if (member.AccessMode.HasFlag(MemberAccessMode.ByLocalRef))
            {
                builder.Append("            var local").Append(member.Name).Append(" = obj.").Append(member.Name).Append(";").AppendLine();
                builder.Append("            this.").Append(serializerField).Append(".Serialize(ref local").Append(member.Name).Append(", mode, stream);").AppendLine();
            }
        }

        private static void EmitDataContractSerializerGenericConstraints(SerializerTypeSpec typeSpec, StringBuilder builder)
        {
            if (typeSpec.Type.TypeParameters.Length > 0)
            {
                foreach (var typeParam in typeSpec.Type.TypeParameters)
                {
                    var constraintBuilder = new StringBuilder();
                    if (typeParam.HasValueTypeConstraint) constraintBuilder.Append("struct");
                    if (typeParam.HasReferenceTypeConstraint) constraintBuilder.Append("class");
                    if (typeParam.HasConstructorConstraint)
                    {
                        if (constraintBuilder.Length > 0)
                        {
                            constraintBuilder.Append(", ");
                        }
                        constraintBuilder.Append("new()");
                    }
                    foreach (var constraintType in typeParam.ConstraintTypes)
                    {
                        if (constraintBuilder.Length > 0)
                        {
                            constraintBuilder.Append(", ");
                        }
                        constraintBuilder.Append(constraintType.ToDisplayString());
                    }

                    if (constraintBuilder.Length > 0)
                    {
                        builder.Append("  where ").Append(typeParam.Name).Append(" : ").Append(constraintBuilder.ToString()).AppendLine();
                    }
                }
            }
        }

        private static void EmitDataContractSerializerField(StringBuilder builder, string fieldName, ITypeSymbol serializerType)
        {
            builder.Append("    private DataSerializer<").Append(serializerType.ToDisplayString()).Append("> ").Append(fieldName).Append(";").AppendLine();
        }

        private static List<(string fieldName, ITypeSymbol type)> GetDataContractSerializerFieldList(SerializerTypeSpec typeSpec)
        {
            var serializers = new List<(string, ITypeSymbol)>();
            foreach (var distinctMemberType in typeSpec.Members.Select(static member => member.Type).Distinct(SymbolEqualityComparer.Default).Cast<ITypeSymbol>())
            {
                serializers.Add((
                    distinctMemberType.ToDisplayString(NamespaceWithTypeNameWithGenerics)
                        .Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(", ", "_").Replace("[]", "Array")
                        + "__Serializer",
                    distinctMemberType));
            }

            return serializers;
        }

        private static string GetDataContractSerializerName(INamedTypeSymbol typeSymbol, bool includeArity)
        {
            const string fmt = "{0}{1}Serializer";
            string arity = string.Empty;
            if (includeArity && typeSymbol.IsGenericType)
            {
                arity = typeSymbol.TypeArguments.Length.ToString();
            }
            return string.Format(fmt, typeSymbol.ToDisplayString(NamespaceWithTypeNameWithoutGenerics).Replace(".", "_"), arity);
        }
    }
}
